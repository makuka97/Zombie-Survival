<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Z-TEAM Remote</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Courier New', monospace; color: #fff; touch-action: none; }
    .screen { display: none; position: fixed; inset: 0; flex-direction: column; align-items: center; justify-content: center; }
    .screen.active { display: flex; }

    /* JOIN */
    #join-screen { gap: 16px; background: #000; }
    #join-screen h1 { font-size: clamp(28px,8vw,48px); color: #00ff00; letter-spacing: 8px; text-shadow: 0 0 20px rgba(0,255,0,0.6); }
    #join-screen h2 { font-size: 12px; color: #333; letter-spacing: 4px; }
    #room-code-input { width: 200px; height: 56px; font-size: 30px; text-align: center; background: #000; border: 3px solid #00ff00; border-radius: 10px; color: #00ff00; letter-spacing: 10px; font-family: 'Courier New', monospace; }
    #join-btn { width: 200px; height: 50px; font-size: 18px; font-weight: bold; background: #00ff00; color: #000; border: none; border-radius: 10px; letter-spacing: 3px; cursor: pointer; font-family: 'Courier New', monospace; }
    #join-btn:active { transform: scale(0.95); }
    #new-room-btn { width: 200px; height: 50px; font-size: 14px; font-weight: bold; background: transparent; color: #00ff00; border: 2px solid #00ff00; border-radius: 10px; letter-spacing: 2px; cursor: pointer; font-family: 'Courier New', monospace; }
    #new-room-btn:active { background: rgba(0,255,0,0.1); }
    #join-divider { color: #333; font-size: 12px; letter-spacing: 3px; }
    #join-error { color: #ff4444; font-size: 13px; min-height: 18px; letter-spacing: 1px; }

    /* LOBBY */
    #lobby-screen { gap: 0; background: #000; justify-content: flex-start; padding: 40px 24px 24px; }
    #lobby-title { font-size: clamp(28px,8vw,48px); color: #00ff00; letter-spacing: 8px; text-shadow: 0 0 20px rgba(0,255,0,0.5); margin-bottom: 6px; }
    #lobby-sub { font-size: 11px; color: #333; letter-spacing: 4px; margin-bottom: 28px; }
    #room-info { width: 100%; max-width: 420px; background: #0a0a0a; border: 2px solid #1a1a1a; border-radius: 12px; padding: 18px 20px; margin-bottom: 20px; }
    #room-info-label { font-size: 10px; color: #444; letter-spacing: 3px; margin-bottom: 8px; }
    #room-code-display { font-size: 42px; color: #00ff00; letter-spacing: 12px; font-weight: bold; text-shadow: 0 0 15px rgba(0,255,0,0.5); margin-bottom: 14px; }
    #share-btn { width: 100%; height: 48px; font-size: 14px; font-weight: bold; background: #00ff00; color: #000; border: none; border-radius: 10px; letter-spacing: 2px; cursor: pointer; font-family: 'Courier New', monospace; }
    #share-btn:active { transform: scale(0.97); }
    #share-btn.copied { background: #00cc00; }
    #player-list { width: 100%; max-width: 420px; display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px; }
    .player-row { display: flex; align-items: center; justify-content: space-between; padding: 10px 16px; border-radius: 8px; background: #0a0a0a; border: 1px solid #1a1a1a; font-size: 14px; letter-spacing: 2px; }
    .player-row .pname { font-weight: bold; }
    .player-row .pstatus { font-size: 11px; color: #444; letter-spacing: 2px; }
    .player-row .pstatus.ready { color: #00ff00; }
    #my-badge { font-size: 18px; font-weight: bold; letter-spacing: 3px; padding: 10px 24px; border-radius: 10px; border: 2px solid; margin-bottom: 20px; text-align: center; }
    #ready-btn { width: 100%; max-width: 420px; height: 64px; font-size: 22px; font-weight: bold; background: #00ff00; color: #000; border: none; border-radius: 14px; letter-spacing: 4px; cursor: pointer; font-family: 'Courier New', monospace; box-shadow: 0 0 24px rgba(0,255,0,0.4); }
    #ready-btn:active { transform: scale(0.97); }
    #ready-btn.voted { background: #1a1a1a; color: #00ff00; border: 2px solid #00ff00; box-shadow: none; font-size: 16px; }
    #waiting-text { font-size: 12px; color: #555; letter-spacing: 2px; margin-top: 10px; animation: pulse 1.5s infinite; }

    /* GAME */
    #game-screen { flex-direction: column; background: #000; justify-content: flex-start; align-items: stretch; }
    #canvas-wrap { position: relative; flex-shrink: 0; width: 100%; background: #000; display: flex; align-items: center; justify-content: center; overflow: hidden; }
    #game-canvas { display: block; }
    #hud-bar { display: flex; justify-content: space-between; align-items: center; padding: 4px 16px; background: #050505; border-top: 1px solid #111; border-bottom: 1px solid #111; flex-shrink: 0; height: 36px; }
    #hud-weapon { font-size: 13px; color: #aaa; letter-spacing: 2px; }
    #hud-wave   { font-size: 13px; color: #555; letter-spacing: 2px; }
    #hud-ammo   { font-size: 15px; font-weight: bold; color: #ffff00; letter-spacing: 2px; }
    #hud-ammo.low   { color: #ff3333; animation: flash 0.5s infinite; }
    #hud-ammo.empty { color: #555; }
    #hud-points { font-size: 13px; color: #00ff00; letter-spacing: 2px; }
    #ctrl-area { height: 170px; flex-shrink: 0; display: flex; align-items: center; justify-content: space-between; padding: 0 28px; }
    #joystick-zone { width: 150px; height: 150px; border-radius: 50%; background: rgba(0,255,0,0.04); border: 3px solid #00ff00; position: relative; touch-action: none; flex-shrink: 0; }
    #joystick-zone::before, #joystick-zone::after { content: ''; position: absolute; background: rgba(0,255,0,0.12); }
    #joystick-zone::before { width:2px; height:100%; top:0; left:50%; transform:translateX(-50%); }
    #joystick-zone::after  { height:2px; width:100%; left:0; top:50%; transform:translateY(-50%); }
    #joystick-knob { width: 56px; height: 56px; border-radius: 50%; background: #00ff00; position: absolute; top:50%; left:50%; transform:translate(-50%,-50%); pointer-events: none; box-shadow: 0 0 16px rgba(0,255,0,0.8); }
    #mystery-box-btn { width: 90px; height: 90px; border-radius: 50%; background: #1a001a; color: #555; border: 3px solid #333; font-size: 10px; font-weight: bold; letter-spacing: 1px; font-family: 'Courier New', monospace; cursor: pointer; line-height: 1.4; flex-shrink: 0; transition: all 0.2s; }
    #mystery-box-btn:disabled { opacity: 0.4; }
    #mystery-box-btn.pulse { background: #2a0044; color: #ff00ff; border-color: #bb00ff; box-shadow: 0 0 20px rgba(187,0,255,0.6); animation: pulsebox 1s infinite; }
    @keyframes pulsebox { 0%,100% { box-shadow: 0 0 20px rgba(187,0,255,0.5); } 50% { box-shadow: 0 0 35px rgba(187,0,255,1); } }
    #fire-btn { width: 130px; height: 130px; border-radius: 50%; background: rgba(255,40,40,0.1); border: 4px solid #ff3333; color: #ff3333; font-size: 18px; font-weight: bold; font-family: 'Courier New', monospace; letter-spacing: 3px; display: flex; flex-direction: column; align-items: center; justify-content: center; touch-action: none; user-select: none; flex-shrink: 0; transition: all 0.12s; box-shadow: 0 0 16px rgba(255,50,50,0.2); }
    #fire-btn .btn-sub { font-size: 9px; letter-spacing: 2px; color: #ff6666; margin-top: 2px; }
    #fire-btn.active { background: #ff3333; color: #000; box-shadow: 0 0 40px rgba(255,50,50,0.9); }
    #fire-btn.melee-mode { border-color: #00ff66; color: #00ff66; background: rgba(0,255,100,0.08); }
    #fire-btn.melee-mode.active { background: #00ff66; color: #000; box-shadow: 0 0 50px rgba(0,255,100,1); }

    /* GAME OVER */
    #gameover-screen { gap: 20px; background: rgba(0,0,0,0.95); }
    #gameover-screen h1 { font-size: clamp(36px,10vw,64px); color: #ff0000; letter-spacing: 6px; text-shadow: 0 0 20px #ff0000; }
    #gameover-screen p  { font-size: 14px; color: #555; letter-spacing: 2px; }
    #restart-btn { width: 260px; height: 64px; font-size: 22px; font-weight: bold; background: #00ff00; color: #000; border: none; border-radius: 14px; letter-spacing: 3px; cursor: pointer; font-family: 'Courier New', monospace; }
    #restart-btn:active { transform: scale(0.95); }
    #restart-btn.voted  { background: #222; color: #555; }
    #vote-status { font-size: 16px; color: #00ff00; letter-spacing: 2px; min-height: 22px; }

    #ping-display { position: fixed; top: 4px; right: 8px; font-size: 9px; color: #333; z-index: 99; }
    #status-bar { position: fixed; bottom: 4px; left: 50%; transform: translateX(-50%); font-size: 9px; color: #222; letter-spacing: 1px; z-index: 99; }

    @keyframes pulse { 0%,100%{opacity:1}50%{opacity:0.2} }
    @keyframes flash  { 0%,100%{opacity:1}50%{opacity:0.2} }
  </style>
</head>
<body>

  <div id="join-screen" class="screen active">
    <h1>Z-TEAM</h1>
    <h2>REMOTE MULTIPLAYER</h2>
    <button id="new-room-btn">CREATE NEW ROOM</button>
    <div id="join-divider">OR JOIN WITH CODE</div>
    <input id="room-code-input" type="text" maxlength="4" placeholder="CODE" autocomplete="off">
    <button id="join-btn">JOIN ROOM</button>
    <div id="join-error"></div>
  </div>

  <div id="lobby-screen" class="screen">
    <div id="lobby-title">Z-TEAM</div>
    <div id="lobby-sub">REMOTE MULTIPLAYER</div>
    <div id="room-info">
      <div id="room-info-label">ROOM CODE</div>
      <div id="room-code-display">----</div>
      <button id="share-btn">SHARE INVITE LINK</button>
    </div>
    <div id="my-badge">PLAYER ?</div>
    <div id="player-list"></div>
    <button id="ready-btn">READY UP</button>
    <div id="waiting-text"></div>
  </div>

  <div id="game-screen" class="screen">
    <div id="canvas-wrap"><canvas id="game-canvas"></canvas></div>
    <div id="hud-bar">
      <div id="hud-weapon">PISTOL</div>
      <div id="hud-wave">WAVE 1</div>
      <div id="hud-ammo">30</div>
      <div id="hud-points">$0</div>
    </div>
    <div id="ctrl-area">
      <div id="joystick-zone"><div id="joystick-knob"></div></div>
      <button id="mystery-box-btn" disabled>MYSTERY<br>BOX<br>$950</button>
      <div id="fire-btn">FIRE<div class="btn-sub">HOLD</div></div>
    </div>
  </div>

  <div id="gameover-screen" class="screen">
    <h1>GAME OVER</h1>
    <p>All players have fallen</p>
    <button id="restart-btn">RESTART</button>
    <div id="vote-status"></div>
  </div>

  <div id="ping-display">-- ms</div>
  <div id="status-bar">CONNECTING...</div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
  'use strict';

  // ── Shared constants (must match server) ─────────────────────────
  const PLAYER_SPEED = 2.5;
  const PLAYER_SIZE  = 28;
  const BULLET_SPEED = 8;
  const CANVAS_W     = 1334;
  const CANVAS_H     = 750;
  const WALL_PAD     = PLAYER_SIZE / 2 + 6;
  const PRED_CORRECT = 0.22;   // lerp strength toward server position per frame
  const SNAP_DIST    = 100;    // px — snap if correction gap is this large

  const WEAPON_FIRE_RATES = {
    pistol: 10, smg: 5, shotgun: 20, ar: 7, lmg: 8, raygun: 12, thundergun: 30
  };

  // ================================================================
  // JOYSTICK
  // ================================================================
  class Joystick {
    constructor(zoneId, knobId) {
      this.zone  = document.getElementById(zoneId);
      this.knob  = document.getElementById(knobId);
      this.angle = null; this.active = false; this.maxR = 46;
      const o = { passive: false };
      this.zone.addEventListener('touchstart',  e => this.onStart(e), o);
      this.zone.addEventListener('touchmove',   e => this.onMove(e),  o);
      this.zone.addEventListener('touchend',    e => this.onEnd(e),   o);
      this.zone.addEventListener('touchcancel', e => this.onEnd(e),   o);
    }
    offset(e) {
      const r = this.zone.getBoundingClientRect();
      const s = e.touches ? e.touches[0] : e;
      return { x: s.clientX - r.left - r.width/2, y: s.clientY - r.top - r.height/2 };
    }
    onStart(e) { e.preventDefault(); this.active = true; this.onMove(e); }
    onMove(e) {
      if (!this.active) return; e.preventDefault();
      const { x, y } = this.offset(e);
      this.angle = Math.atan2(y, x);
      const c = Math.min(Math.sqrt(x*x+y*y), this.maxR);
      this.knob.style.transform = `translate(calc(-50% + ${Math.cos(this.angle)*c}px), calc(-50% + ${Math.sin(this.angle)*c}px))`;
    }
    onEnd(e) { e.preventDefault(); this.active = false; this.angle = null; this.knob.style.transform = 'translate(-50%,-50%)'; }
    getAngle() { return this.active ? this.angle : null; }
  }

  // ================================================================
  // CLIENT-SIDE PREDICTION ENGINE
  // Runs our player locally at 60 fps so movement feels instant.
  // Server state reconciles the position smoothly every ~33ms.
  // ================================================================
  class Prediction {
    constructor(slot, color) {
      this.slot    = slot;
      this.color   = color;
      this.x       = 80;
      this.y       = 80;
      this.angle   = 0;
      this.alive   = true;
      this.hp      = 100;
      this.maxHp   = 100;
      this.seeded  = false;
      this.fireRate = 10;
      this.fireCd   = 0;
      this.bullets  = []; // local predicted bullets (visual only)
    }

    // Called once when first server state arrives
    seed(sp) {
      this.x = sp.x; this.y = sp.y; this.angle = sp.angle;
      this.alive = sp.alive; this.hp = sp.hp; this.maxHp = sp.maxHp;
      this.seeded = true;
    }

    // 60Hz local tick — runs physics locally for zero-latency feel
    tick(joystickAngle, firing, inMeleeMode) {
      // Move
      if (joystickAngle !== null && this.alive) {
        this.angle = joystickAngle;
        this.x = Math.max(WALL_PAD, Math.min(CANVAS_W - WALL_PAD, this.x + Math.cos(joystickAngle) * PLAYER_SPEED));
        this.y = Math.max(WALL_PAD, Math.min(CANVAS_H - WALL_PAD, this.y + Math.sin(joystickAngle) * PLAYER_SPEED));
      }

      // Fire predicted bullets (visual only — damage handled server side)
      this.fireCd--;
      if (firing && !inMeleeMode && this.alive && this.fireCd <= 0) {
        this.bullets.push({
          x: this.x + Math.cos(this.angle) * PLAYER_SIZE,
          y: this.y + Math.sin(this.angle) * PLAYER_SIZE,
          vx: Math.cos(this.angle) * BULLET_SPEED,
          vy: Math.sin(this.angle) * BULLET_SPEED,
          life: 55, color: this.color
        });
        this.fireCd = this.fireRate;
      }

      // Advance predicted bullets
      for (let i = this.bullets.length - 1; i >= 0; i--) {
        const b = this.bullets[i];
        b.x += b.vx; b.y += b.vy; b.life--;
        if (b.life <= 0 || b.x < 0 || b.x > CANVAS_W || b.y < 0 || b.y > CANVAS_H)
          this.bullets.splice(i, 1);
      }
    }

    // Called each time server state arrives — smooth correction
    reconcile(sp) {
      // Always sync non-positional state from server (hp, alive)
      this.alive = sp.alive;
      this.hp    = sp.hp;
      this.maxHp = sp.maxHp;

      if (!this.alive) { this.x = sp.x; this.y = sp.y; return; }

      const dx   = sp.x - this.x;
      const dy   = sp.y - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist > SNAP_DIST) {
        // Large correction — snap instantly (shouldn't happen often)
        this.x = sp.x; this.y = sp.y;
      } else if (dist > 1.5) {
        // Small drift — lerp smoothly so it's invisible to the player
        this.x += dx * PRED_CORRECT;
        this.y += dy * PRED_CORRECT;
      }
    }

    // Remove predicted bullets near a confirmed server hit
    clearNear(x, y) {
      this.bullets = this.bullets.filter(b => Math.sqrt((b.x-x)**2+(b.y-y)**2) > 40);
    }
  }

  // ================================================================
  // INTERPOLATOR — smooths other players + zombies between server ticks
  // Server runs at 30Hz (33ms), we render at 60Hz (16ms).
  // Each entity glides from its previous position to its new one
  // over exactly one server tick duration — looks perfectly smooth.
  // ================================================================
  class Interpolator {
    constructor() {
      this.players = new Map(); // slot -> interpolated player state
      this.zombies = [];        // interpolated zombie array for rendering
      this._zombiePrev = [];
      this._zombieNext = [];
      this._t = 0;
      this._lastServerTime = 0;
      this.SERVER_TICK = 1000 / 30; // 33ms
    }

    // Call every time a new server state arrives
    onServerState(state, mySlot) {
      this._t = 0;
      this._lastServerTime = Date.now();

      // Other players
      for (const sp of state.players) {
        if (!sp.connected || sp.slot === mySlot) continue;
        const existing = this.players.get(sp.slot);
        if (existing) {
          existing.prev  = { x: existing.x, y: existing.y, angle: existing.angle };
          existing.next  = { x: sp.x, y: sp.y, angle: sp.angle };
          existing.alive = sp.alive; existing.hp = sp.hp; existing.maxHp = sp.maxHp;
          existing.points = sp.points; existing.color = sp.color;
        } else {
          // Seed x/y to server position so player renders immediately on first frame
          this.players.set(sp.slot, {
            prev:  { x: sp.x, y: sp.y, angle: sp.angle },
            next:  { x: sp.x, y: sp.y, angle: sp.angle },
            x: sp.x, y: sp.y, angle: sp.angle,
            alive: sp.alive, hp: sp.hp, maxHp: sp.maxHp,
            points: sp.points, color: sp.color, slot: sp.slot
          });
        }
      }
      // Remove disconnected players
      for (const [slot] of this.players) {
        if (!state.players.find(p => p.slot === slot && p.connected)) this.players.delete(slot);
      }

      // Zombies — prev = current interpolated positions (smooth), fallback to server pos for new zombies
      this._zombiePrev = state.zombies.map((zNext, i) => {
        const cur = this.zombies[i];
        return cur ? { x: cur.x, y: cur.y } : { x: zNext.x, y: zNext.y };
      });
      this._zombieNext = state.zombies;
    }

    // Call every frame (60Hz) — advances interpolation progress
    tick() {
      const t = Math.min((Date.now() - this._lastServerTime) / this.SERVER_TICK, 1);

      // Interpolate other players
      for (const [, p] of this.players) {
        p.x = p.prev.x + (p.next.x - p.prev.x) * t;
        p.y = p.prev.y + (p.next.y - p.prev.y) * t;
        let da = p.next.angle - p.prev.angle;
        while (da >  Math.PI) da -= Math.PI * 2;
        while (da < -Math.PI) da += Math.PI * 2;
        p.angle = p.prev.angle + da * t;
      }

      // Interpolate zombies
      this.zombies = this._zombieNext.map((zNext, i) => {
        const zPrev = this._zombiePrev[i];
        if (!zPrev) return zNext;
        return { ...zNext, x: zPrev.x + (zNext.x - zPrev.x) * t, y: zPrev.y + (zNext.y - zPrev.y) * t };
      });
    }
  }

  // ================================================================
  // RENDERER — draws server state + local prediction at 60fps
  // ================================================================
  class Renderer {
    constructor(canvas) {
      this.canvas    = canvas;
      this.ctx       = canvas.getContext('2d');
      this.BASE_W    = CANVAS_W;
      this.BASE_H    = CANVAS_H;
      this.particles = [];
      this.melees    = [];
      this.waveText  = '';
      this.waveTimer = 0;
      this.resize();
      window.addEventListener('resize', () => this.resize());
    }

    resize() {
      const W      = window.innerWidth;
      const availH = window.innerHeight - 170 - 36;
      const scale  = Math.min(W / this.BASE_W, availH / this.BASE_H);
      this.canvas.width  = this.BASE_W;
      this.canvas.height = this.BASE_H;
      this.canvas.style.width  = Math.floor(this.BASE_W * scale) + 'px';
      this.canvas.style.height = Math.floor(this.BASE_H * scale) + 'px';
      document.getElementById('canvas-wrap').style.height = Math.floor(this.BASE_H * scale) + 'px';
    }

    showWave(text) { this.waveText = text; this.waveTimer = 150; }

    spawnParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2, s = 1.5 + Math.random()*4, l = 18 + Math.random()*20|0;
        this.particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, color, life: l, maxLife: l, size: 2+Math.random()*4 });
      }
    }

    // state      = latest server snapshot
    // pred       = Prediction instance (our player + local bullets)
    // mySlot     = which slot is us
    draw(state, pred, mySlot, interp) {
      const ctx = this.ctx, W = this.BASE_W, H = this.BASE_H;

      // Tick particles + effects
      for (let i = this.particles.length-1; i >= 0; i--) {
        const p = this.particles[i];
        p.x += p.vx; p.y += p.vy; p.vx *= 0.92; p.vy *= 0.92; p.life--;
        if (p.life <= 0) this.particles.splice(i, 1);
      }
      for (let i = this.melees.length-1; i >= 0; i--) {
        if (--this.melees[i].timer <= 0) this.melees.splice(i, 1);
      }
      if (this.waveTimer > 0) this.waveTimer--;

      // Consume server explosion events
      if (state.explosions) {
        for (const ex of state.explosions) {
          if (ex.melee) this.melees.push({ x: ex.x, y: ex.y, angle: ex.angle, color: ex.color, timer: 8 });
          else          this.spawnParticles(ex.x, ex.y, ex.color, ex.big ? 24 : 10);
          if (pred)     pred.clearNear(ex.x, ex.y);
        }
      }

      // ── Background ────────────────────────────────────────────────
      ctx.fillStyle = '#111'; ctx.fillRect(0, 0, W, H);
      ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 60) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for (let y = 0; y < H; y += 60) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

      // ── Mystery box ───────────────────────────────────────────────
      if (state.mysteryBox) {
        const b = state.mysteryBox;
        ctx.fillStyle = '#1a001a'; ctx.fillRect(b.x-18, b.y-18, 36, 36);
        ctx.strokeStyle = '#bb00ff'; ctx.lineWidth = 2; ctx.strokeRect(b.x-18, b.y-18, 36, 36);
        ctx.fillStyle = '#bb00ff'; ctx.font = 'bold 18px Courier New';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('?', b.x, b.y);
      }

      // ── Ammo packs ────────────────────────────────────────────────
      for (const a of state.ammoPacks) {
        ctx.fillStyle = '#ffff00'; ctx.fillRect(a.x-10, a.y-10, 20, 20);
        ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 2; ctx.strokeRect(a.x-10, a.y-10, 20, 20);
        ctx.fillStyle = '#000'; ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('A', a.x, a.y);
      }

      // ── Health packs ──────────────────────────────────────────────
      for (const h of state.healthPacks) {
        ctx.fillStyle = '#222'; ctx.fillRect(h.x-10, h.y-10, 20, 20);
        ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2; ctx.strokeRect(h.x-10, h.y-10, 20, 20);
        ctx.fillStyle = '#ff3333'; ctx.fillRect(h.x-7, h.y-2, 14, 4); ctx.fillRect(h.x-2, h.y-7, 4, 14);
      }

      // ── Particles ─────────────────────────────────────────────────
      for (const pt of this.particles) {
        const a = pt.life / pt.maxLife;
        ctx.save(); ctx.globalAlpha = a;
        ctx.fillStyle = pt.color; ctx.shadowColor = pt.color; ctx.shadowBlur = 6;
        ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.size*a, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // ── Melee flashes ─────────────────────────────────────────────
      for (const f of this.melees) {
        ctx.save(); ctx.globalAlpha = f.timer/8;
        ctx.strokeStyle = f.color; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(f.x, f.y, 55, f.angle-Math.PI*0.3, f.angle+Math.PI*0.3); ctx.stroke();
        ctx.restore();
      }

      // ── Zombies (interpolated) ───────────────────────────────────
      const zombiesToDraw = interp ? interp.zombies : state.zombies;
      for (const z of zombiesToDraw) {
        const hs = z.size/2;
        ctx.fillStyle = z.color; ctx.fillRect(z.x-hs, z.y-hs, z.size, z.size);
        ctx.strokeStyle = z.borderColor; ctx.lineWidth = 2; ctx.strokeRect(z.x-hs, z.y-hs, z.size, z.size);
        ctx.fillStyle = '#ff0000'; ctx.fillRect(z.x-hs, z.y-hs-8, z.size, 4);
        ctx.fillStyle = '#00ff00'; ctx.fillRect(z.x-hs, z.y-hs-8, z.size*(z.hp/z.maxHp), 4);
      }

      // ── Local predicted bullets (instant feel) ────────────────────
      if (pred) {
        for (const b of pred.bullets) {
          ctx.fillStyle = b.color; ctx.shadowColor = b.color; ctx.shadowBlur = 8;
          ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      // ── Boss ──────────────────────────────────────────────────────
      if (state.boss && !state.boss.dead) {
        const b = state.boss;
        const flash = b.flashTimer > 0 && b.flashTimer % 2 === 0;
        ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(b.rotation);
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
          const a = -Math.PI/2 + i*(2*Math.PI/3);
          i===0 ? ctx.moveTo(Math.cos(a)*b.radius, Math.sin(a)*b.radius)
                : ctx.lineTo(Math.cos(a)*b.radius, Math.sin(a)*b.radius);
        }
        ctx.closePath();
        ctx.fillStyle = flash ? '#ffffff' : b.color;
        ctx.shadowColor = '#bb00ff'; ctx.shadowBlur = 30; ctx.fill();
        ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.stroke();
        ctx.shadowBlur = 0; ctx.restore();
        const tipAngles = [0,1,2].map(i => b.rotation - Math.PI/2 + i*(2*Math.PI/3));
        for (let t = 0; t < 3; t++) {
          if (b.tips[t].hp <= 0) continue;
          const tx = b.x + Math.cos(tipAngles[t])*b.radius;
          const ty = b.y + Math.sin(tipAngles[t])*b.radius;
          ctx.save(); ctx.translate(tx, ty); ctx.rotate(b.rotation+t*(2*Math.PI/3));
          ctx.beginPath(); ctx.moveTo(0,-20); ctx.lineTo(12,14); ctx.lineTo(-12,14); ctx.closePath();
          ctx.fillStyle = flash ? '#ffffff' : '#ff00ff';
          ctx.shadowColor = '#ff00ff'; ctx.shadowBlur = 15; ctx.fill(); ctx.shadowBlur = 0; ctx.restore();
          ctx.fillStyle = '#440044'; ctx.fillRect(tx-18, ty-30, 36, 5);
          ctx.fillStyle = '#ff00ff'; ctx.fillRect(tx-18, ty-30, 36*(b.tips[t].hp/b.tips[t].maxHp), 5);
        }
        ctx.fillStyle = '#ff44ff'; ctx.font = 'bold 16px Courier New';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('BOSS', b.x, b.y - b.radius - 20);
      }

      // ── Players ───────────────────────────────────────────────────
      for (const sp of state.players) {
        if (!sp.connected) continue;
        const isMe = sp.slot === mySlot;
        // Our player: use local prediction. Other players: use interpolated position (fallback to server).
        const ip = (!isMe && interp) ? interp.getPlayer(sp.slot) : null;
        const px = isMe && pred ? pred.x     : (ip ? ip.x     : sp.x);
        const py = isMe && pred ? pred.y     : (ip ? ip.y     : sp.y);
        const pa = isMe && pred ? pred.angle : (ip ? ip.angle : sp.angle);
        const ph = isMe && pred ? pred.hp    : (ip ? ip.hp    : sp.hp);
        const pm = isMe && pred ? pred.maxHp : (ip ? ip.maxHp : sp.maxHp);
        const alive = isMe && pred ? pred.alive : (ip ? ip.alive : sp.alive);
        const hs = 14;

        if (!alive) {
          ctx.globalAlpha = 0.3;
          ctx.fillStyle = sp.color; ctx.fillRect(px-hs, py-hs, hs*2, hs*2);
          ctx.globalAlpha = 1; continue;
        }

        ctx.save(); ctx.translate(px, py); ctx.rotate(pa);
        ctx.fillStyle = sp.color; ctx.shadowColor = sp.color; ctx.shadowBlur = 10;
        ctx.fillRect(-hs, -hs, hs*2, hs*2);
        ctx.fillStyle = '#000'; ctx.fillRect(4, -4, 12, 8);
        ctx.shadowBlur = 0; ctx.restore();

        ctx.fillStyle = '#333'; ctx.fillRect(px-hs, py-hs-10, hs*2, 5);
        ctx.fillStyle = ph > 40 ? '#00ff00' : ph > 20 ? '#ffff00' : '#ff0000';
        ctx.fillRect(px-hs, py-hs-10, (hs*2)*(ph/pm), 5);

        ctx.fillStyle = '#fff'; ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('P'+sp.slot, px, py);

        ctx.fillStyle = sp.color; ctx.font = 'bold 10px Courier New';
        ctx.textBaseline = 'bottom';
        ctx.fillText('$'+sp.points, px, py-hs-12);

        if (isMe) {
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.35;
          ctx.strokeRect(px-hs-4, py-hs-4, (hs+4)*2, (hs+4)*2);
          ctx.globalAlpha = 1;
        }
      }

      // ── Border (always on top) ────────────────────────────────────
      ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 4;
      ctx.shadowColor = '#00ff00'; ctx.shadowBlur = 12;
      ctx.strokeRect(2, 2, W-4, H-4);
      ctx.shadowBlur = 0;

      // ── Wave banner ───────────────────────────────────────────────
      if (this.waveTimer > 0) {
        const alpha = Math.min(1, this.waveTimer/30);
        ctx.save(); ctx.globalAlpha = alpha;
        ctx.font = 'bold 48px Courier New'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillStyle = this.waveText.includes('BOSS') ? '#ff00ff' : '#ff3300';
        ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 30;
        ctx.fillText(this.waveText, W/2, H/2);
        ctx.shadowBlur = 0; ctx.restore();
      }

      ctx.fillStyle = '#333'; ctx.font = '14px Courier New';
      ctx.textAlign = 'right'; ctx.textBaseline = 'top';
      ctx.fillText('WAVE ' + state.wave, W-12, 12);
    }
  }

  // ================================================================
  // REMOTE CLIENT
  // ================================================================
  class RemoteClient {
    constructor() {
      this.socket = io({
        transports: ['websocket'],
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: 500,
        reconnectionDelayMax: 2000,
        timeout: 5000
      });

      this.roomCode    = null;
      this.slot        = null;
      this.color       = null;
      this.firing      = false;
      this.meleeing    = false;
      this.inMeleeMode = false;
      this.isReady     = false;
      this.hasVoted    = false;

      this.pred      = null;   // Prediction engine
      this.renderer  = null;   // Renderer
      this.interp    = null;   // Entity interpolator
      this.lastState = null;   // Latest server snapshot

      this.inputTimer = null;  // 20Hz input send loop
      this.simTimer   = null;  // 60Hz local sim + render loop
      this.pingTimer  = null;
      this.pingStart  = 0;

      this.joystick = new Joystick('joystick-zone', 'joystick-knob');
      this.fp = this.loadFP();

      this.bindSocket();
      this.bindJoinUI();
      this.bindLobbyUI();
      this.bindGameUI();
      this.bindGameoverUI();
      this.checkDeepLink();
    }

    loadFP() {
      let fp = sessionStorage.getItem('zt-fp');
      if (!fp) { fp = 'fp-'+Date.now()+'-'+Math.random().toString(36).slice(2); sessionStorage.setItem('zt-fp', fp); }
      return fp;
    }

    checkDeepLink() {
      const code = new URLSearchParams(window.location.search).get('room');
      if (code && code.length === 4) {
        document.getElementById('room-code-input').value = code.toUpperCase();
        this._pending = code.toUpperCase();
      }
    }

    bindSocket() {
      this.socket.on('connect', () => {
        this.setStatus('OK');
        if (this._pending) { this.joinRoom(this._pending); this._pending = null; }
        else if (this.roomCode) this.socket.emit('join-room', { roomCode: this.roomCode, deviceFingerprint: this.fp });
        this.startPingLoop();
      });

      this.socket.on('disconnect', () => {
        this.setStatus('RECONNECTING...');
        this.stopGame();
      });

      this.socket.on('pong-ack', () => {
        const ms = Date.now() - this.pingStart;
        document.getElementById('ping-display').textContent = ms + ' ms';
      });

      this.socket.on('join-success',  d => this.onJoinSuccess(d));
      this.socket.on('join-failed',   d => this.showError(d.reason));
      this.socket.on('lobby-update',  d => this.updateLobby(d));
      this.socket.on('game-starting-remote', () => this.startGame());

      // Server state arrives ~30Hz — reconcile prediction, update HUD
      this.socket.on('remote-game-state', state => {
        this.lastState = state;

        if (this.pred && state.players) {
          const sp = state.players[this.slot - 1];
          if (sp) {
            if (!this.pred.seeded) this.pred.seed(sp);
            else                   this.pred.reconcile(sp);
          }
        }
        // Feed new state to interpolator for other players + zombies
        if (this.interp) this.interp.onServerState(state, this.slot);

        this.updateHUD(state);
        if (state.gameOver) this.showScreen('gameover-screen');
      });

      this.socket.on('wave-event', d => {
        if (this.renderer) this.renderer.showWave(d.type === 'boss' ? 'BOSS WAVE' : 'WAVE ' + d.wave);
      });

      this.socket.on('game-over', () => this.showScreen('gameover-screen'));

      this.socket.on('restart-vote-update', d => {
        document.getElementById('vote-status').textContent = `Votes: ${d.votes} / ${d.needed}`;
      });

      this.socket.on('game-restarting-remote', () => {
        this.isReady = false; this.hasVoted = false;
        this.stopGame();
        this.showScreen('lobby-screen');
        document.getElementById('ready-btn').textContent = 'READY UP';
        document.getElementById('ready-btn').classList.remove('voted');
        document.getElementById('waiting-text').textContent = '';
      });
    }

    startPingLoop() {
      if (this.pingTimer) clearInterval(this.pingTimer);
      this.pingTimer = setInterval(() => {
        this.pingStart = Date.now();
        this.socket.emit('ping-measure');
      }, 2000);
    }

    bindJoinUI() {
      document.getElementById('new-room-btn').addEventListener('click', () => {
        this.socket.emit('create-remote-room');
      });
      document.getElementById('join-btn').addEventListener('click', () => {
        const code = document.getElementById('room-code-input').value.trim().toUpperCase();
        if (code.length !== 4) { this.showError('Enter a 4-character code'); return; }
        this.joinRoom(code);
      });
      const input = document.getElementById('room-code-input');
      input.addEventListener('input',    e => { e.target.value = e.target.value.toUpperCase(); });
      input.addEventListener('keypress', e => { if (e.key==='Enter') document.getElementById('join-btn').click(); });
    }

    joinRoom(code) {
      this.roomCode = code;
      sessionStorage.setItem('zt-room', code);
      this.socket.emit('join-room', { roomCode: code, deviceFingerprint: this.fp });
    }

    onJoinSuccess(data) {
      this.slot = data.slotNumber; this.color = data.color; this.roomCode = data.roomCode;
      sessionStorage.setItem('zt-fp', data.deviceFingerprint);
      document.getElementById('room-code-display').textContent = this.roomCode;
      const badge = document.getElementById('my-badge');
      badge.textContent = 'PLAYER ' + this.slot;
      badge.style.color = this.color; badge.style.borderColor = this.color;
      this.showScreen('lobby-screen');
      this.setStatus('P' + this.slot);
      this.requestWakeLock();
    }

    bindLobbyUI() {
      document.getElementById('share-btn').addEventListener('click', async () => {
        const url = `${window.location.origin}/join/${this.roomCode}`;
        const btn = document.getElementById('share-btn');
        if (navigator.share) {
          try { await navigator.share({ title: 'Z-TEAM', text: `Join! Room: ${this.roomCode}`, url }); } catch(e) {}
        } else {
          try {
            await navigator.clipboard.writeText(url);
            btn.textContent = 'LINK COPIED!'; btn.classList.add('copied');
            setTimeout(() => { btn.textContent = 'SHARE INVITE LINK'; btn.classList.remove('copied'); }, 2000);
          } catch(e) {}
        }
      });

      document.getElementById('ready-btn').addEventListener('click', () => {
        if (this.isReady) return;
        this.isReady = true;
        document.getElementById('ready-btn').textContent = 'READY!';
        document.getElementById('ready-btn').classList.add('voted');
        document.getElementById('waiting-text').textContent = 'Waiting for others...';
        this.socket.emit('player-ready', { roomCode: this.roomCode });
      });
    }

    updateLobby(data) {
      const list = document.getElementById('player-list');
      list.innerHTML = '';
      for (let s = 1; s <= 4; s++) {
        const p = data.players.find(p => p.slotNumber === s);
        const row = document.createElement('div');
        row.className = 'player-row';
        if (p) {
          row.innerHTML = `<span class="pname" style="color:${p.color}">PLAYER ${p.slotNumber}${p.slotNumber===this.slot?' (YOU)':''}</span>
            <span class="pstatus ${p.ready?'ready':''}">${p.ready?'READY':'WAITING'}</span>`;
        } else {
          row.innerHTML = `<span class="pname" style="color:#333">PLAYER ${s}</span><span class="pstatus">OPEN</span>`;
        }
        list.appendChild(row);
      }
    }

    bindGameUI() {
      const fireBtn = document.getElementById('fire-btn');
      const press = e => {
        e.preventDefault();
        if (this.inMeleeMode) this.meleeing = true; else this.firing = true;
        fireBtn.classList.add('active');
      };
      const release = e => {
        e.preventDefault(); this.firing = false; this.meleeing = false; fireBtn.classList.remove('active');
      };
      fireBtn.addEventListener('touchstart',  press,   { passive: false });
      fireBtn.addEventListener('touchend',    release, { passive: false });
      fireBtn.addEventListener('touchcancel', release, { passive: false });
      document.getElementById('mystery-box-btn').addEventListener('click', () => {
        this.socket.emit('mystery-box-purchase', { roomCode: this.roomCode });
      });
    }

    startGame() {
      this.showScreen('game-screen');
      setTimeout(() => {
        // Init renderer + prediction engine
        this.renderer = new Renderer(document.getElementById('game-canvas'));
        this.pred     = new Prediction(this.slot, this.color);
        this.interp   = new Interpolator();

        // 60Hz sim loop — prediction ticks + renders every frame
        this.simTimer = setInterval(() => {
          if (!this.lastState) return;
          this.pred.tick(this.joystick.getAngle(), this.firing, this.inMeleeMode);
          this.interp.tick();  // advance interpolation progress at 60fps
          this.renderer.draw(this.lastState, this.pred, this.slot, this.interp);
        }, 1000 / 60);

        // 20Hz input loop — send to server independently of render
        this.inputTimer = setInterval(() => {
          if (!this.roomCode) return;
          this.socket.emit('player-input', {
            roomCode: this.roomCode,
            input: { angle: this.joystick.getAngle(), fire: this.firing, melee: this.meleeing }
          });
        }, 50); // 20Hz

      }, 100);
    }

    stopGame() {
      if (this.simTimer)   { clearInterval(this.simTimer);   this.simTimer   = null; }
      if (this.inputTimer) { clearInterval(this.inputTimer); this.inputTimer = null; }
    }

    updateHUD(state) {
      const p = state.players?.[this.slot - 1];
      if (!p) return;

      const ammoEl = document.getElementById('hud-ammo');
      if (p.ammo === -1)    { ammoEl.textContent = '∞';   ammoEl.className = ''; this.setMeleeMode(false); }
      else if (p.ammo === 0){ ammoEl.textContent = 'OUT'; ammoEl.className = 'empty'; this.setMeleeMode(true); }
      else {
        ammoEl.textContent = p.ammo;
        ammoEl.className   = p.ammo <= 5 ? 'low' : '';
        this.setMeleeMode(false);
        if (this.pred) this.pred.fireRate = WEAPON_FIRE_RATES[p.weapon] || 10;
      }

      document.getElementById('hud-weapon').textContent = (p.weapon||'pistol').toUpperCase().replace('_',' ');
      document.getElementById('hud-points').textContent = '$' + p.points;
      document.getElementById('hud-wave').textContent   = 'WAVE ' + state.wave;

      const box = document.getElementById('mystery-box-btn');
      if (p.canUseMysteryBox && p.points >= 950) { box.disabled = false; box.classList.add('pulse'); }
      else                                        { box.disabled = true;  box.classList.remove('pulse'); }
    }

    setMeleeMode(active) {
      if (this.inMeleeMode === active) return;
      this.inMeleeMode = active;
      const btn = document.getElementById('fire-btn');
      if (active) { btn.classList.add('melee-mode'); btn.childNodes[0].textContent = 'KNIFE'; this.firing = false; }
      else        { btn.classList.remove('melee-mode'); btn.childNodes[0].textContent = 'FIRE'; this.meleeing = false; }
    }

    bindGameoverUI() {
      document.getElementById('restart-btn').addEventListener('click', () => {
        if (this.hasVoted) return;
        this.hasVoted = true;
        document.getElementById('restart-btn').textContent = 'VOTED!';
        document.getElementById('restart-btn').classList.add('voted');
        document.getElementById('vote-status').textContent = 'Waiting for others...';
        this.socket.emit('restart-vote-remote', { roomCode: this.roomCode });
      });
    }

    showScreen(id) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(id).classList.add('active');
      if (id === 'game-screen' && this.renderer) setTimeout(() => this.renderer.resize(), 50);
    }

    showError(msg) {
      const el = document.getElementById('join-error');
      el.textContent = msg;
      setTimeout(() => { el.textContent = ''; }, 3000);
    }

    setStatus(msg) { document.getElementById('status-bar').textContent = msg; }

    async requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          await navigator.wakeLock.request('screen');
          document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') try { await navigator.wakeLock.request('screen'); } catch(_){}
          });
        }
      } catch(e) {}
    }
  }

  const client = new RemoteClient();
  document.body.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
  </script>
</body>
</html>
