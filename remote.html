<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Z-TEAM Remote</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: #000; font-family: 'Courier New', monospace;
      color: #fff; touch-action: none;
    }

    /* ── SCREENS ─────────────────────────────────────────────────────── */
    .screen {
      display: none; position: fixed; inset: 0;
      flex-direction: column; align-items: center; justify-content: center;
    }
    .screen.active { display: flex; }

    /* ── JOIN SCREEN ──────────────────────────────────────────────────── */
    #join-screen { gap: 16px; background: #000; }
    #join-screen h1 { font-size: clamp(28px,8vw,48px); color: #00ff00; letter-spacing: 8px;
      text-shadow: 0 0 20px rgba(0,255,0,0.6); }
    #join-screen h2 { font-size: 12px; color: #333; letter-spacing: 4px; }
    #room-code-input {
      width: 200px; height: 56px; font-size: 30px; text-align: center;
      background: #000; border: 3px solid #00ff00; border-radius: 10px;
      color: #00ff00; letter-spacing: 10px; font-family: 'Courier New', monospace;
    }
    #join-btn {
      width: 200px; height: 50px; font-size: 18px; font-weight: bold;
      background: #00ff00; color: #000; border: none; border-radius: 10px;
      letter-spacing: 3px; cursor: pointer; font-family: 'Courier New', monospace;
    }
    #join-btn:active { transform: scale(0.95); }
    #new-room-btn {
      width: 200px; height: 50px; font-size: 14px; font-weight: bold;
      background: transparent; color: #00ff00; border: 2px solid #00ff00;
      border-radius: 10px; letter-spacing: 2px; cursor: pointer;
      font-family: 'Courier New', monospace;
    }
    #new-room-btn:active { background: rgba(0,255,0,0.1); }
    #join-divider { color: #333; font-size: 12px; letter-spacing: 3px; }
    #join-error { color: #ff4444; font-size: 13px; min-height: 18px; letter-spacing: 1px; }

    /* ── LOBBY SCREEN ─────────────────────────────────────────────────── */
    #lobby-screen { gap: 0; background: #000; justify-content: flex-start; padding: 40px 24px 24px; }

    #lobby-title { font-size: clamp(28px,8vw,48px); color: #00ff00; letter-spacing: 8px;
      text-shadow: 0 0 20px rgba(0,255,0,0.5); margin-bottom: 6px; }
    #lobby-sub { font-size: 11px; color: #333; letter-spacing: 4px; margin-bottom: 28px; }

    #room-info {
      width: 100%; max-width: 420px;
      background: #0a0a0a; border: 2px solid #1a1a1a;
      border-radius: 12px; padding: 18px 20px; margin-bottom: 20px;
    }
    #room-info-label { font-size: 10px; color: #444; letter-spacing: 3px; margin-bottom: 8px; }
    #room-code-display {
      font-size: 42px; color: #00ff00; letter-spacing: 12px; font-weight: bold;
      text-shadow: 0 0 15px rgba(0,255,0,0.5); margin-bottom: 14px;
    }
    #share-btn {
      width: 100%; height: 48px; font-size: 14px; font-weight: bold;
      background: #00ff00; color: #000; border: none; border-radius: 10px;
      letter-spacing: 2px; cursor: pointer; font-family: 'Courier New', monospace;
    }
    #share-btn:active { transform: scale(0.97); }
    #share-btn.copied { background: #00cc00; }

    #player-list {
      width: 100%; max-width: 420px;
      display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px;
    }
    .player-row {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 16px; border-radius: 8px;
      background: #0a0a0a; border: 1px solid #1a1a1a;
      font-size: 14px; letter-spacing: 2px;
    }
    .player-row .pname { font-weight: bold; }
    .player-row .pstatus { font-size: 11px; color: #444; letter-spacing: 2px; }
    .player-row .pstatus.ready { color: #00ff00; }
    .player-row.me { border-color: #333; }

    #my-badge {
      font-size: 18px; font-weight: bold; letter-spacing: 3px;
      padding: 10px 24px; border-radius: 10px; border: 2px solid;
      margin-bottom: 20px; text-align: center;
    }

    #ready-btn {
      width: 100%; max-width: 420px; height: 64px; font-size: 22px;
      font-weight: bold; background: #00ff00; color: #000;
      border: none; border-radius: 14px; letter-spacing: 4px;
      cursor: pointer; font-family: 'Courier New', monospace;
      box-shadow: 0 0 24px rgba(0,255,0,0.4);
    }
    #ready-btn:active { transform: scale(0.97); }
    #ready-btn.voted { background: #1a1a1a; color: #00ff00; border: 2px solid #00ff00; box-shadow: none; font-size: 16px; }
    #waiting-text { font-size: 12px; color: #555; letter-spacing: 2px; margin-top: 10px;
      animation: pulse 1.5s infinite; }

    /* ── GAME SCREEN ──────────────────────────────────────────────────── */
    #game-screen {
      flex-direction: column; background: #000;
      justify-content: flex-start; align-items: stretch;
    }

    /* Canvas area — top portion */
    #canvas-wrap {
      position: relative; flex-shrink: 0;
      width: 100%; background: #000;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden;
    }
    #game-canvas { display: block; image-rendering: pixelated; }

    /* HUD bar between canvas and controls */
    #hud-bar {
      display: flex; justify-content: space-between; align-items: center;
      padding: 4px 16px; background: #050505;
      border-top: 1px solid #111; border-bottom: 1px solid #111;
      flex-shrink: 0; height: 36px;
    }
    #hud-weapon  { font-size: 13px; color: #aaa; letter-spacing: 2px; }
    #hud-wave    { font-size: 13px; color: #555; letter-spacing: 2px; }
    #hud-ammo    { font-size: 15px; font-weight: bold; color: #ffff00; letter-spacing: 2px; }
    #hud-ammo.low   { color: #ff3333; animation: flash 0.5s infinite; }
    #hud-ammo.empty { color: #555; }
    #hud-points  { font-size: 13px; color: #00ff00; letter-spacing: 2px; }

    /* Controls area — bottom portion */
    #ctrl-area {
      height: 170px; flex-shrink: 0;
      display: flex; align-items: center;
      justify-content: space-between;
      padding: 0 28px;
    }

    #joystick-zone {
      width: 150px; height: 150px; border-radius: 50%;
      background: rgba(0,255,0,0.04); border: 3px solid #00ff00;
      position: relative; touch-action: none; flex-shrink: 0;
    }
    #joystick-zone::before, #joystick-zone::after {
      content: ''; position: absolute; background: rgba(0,255,0,0.12);
    }
    #joystick-zone::before { width:2px; height:100%; top:0; left:50%; transform:translateX(-50%); }
    #joystick-zone::after  { height:2px; width:100%; left:0; top:50%; transform:translateY(-50%); }
    #joystick-knob {
      width: 56px; height: 56px; border-radius: 50%; background: #00ff00;
      position: absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      pointer-events: none; box-shadow: 0 0 16px rgba(0,255,0,0.8);
    }

    #mystery-box-btn {
      width: 90px; height: 90px; border-radius: 50%;
      background: #1a001a; color: #555; border: 3px solid #333;
      font-size: 10px; font-weight: bold; letter-spacing: 1px;
      font-family: 'Courier New', monospace; cursor: pointer;
      line-height: 1.4; flex-shrink: 0; transition: all 0.2s;
    }
    #mystery-box-btn:disabled { opacity: 0.4; }
    #mystery-box-btn.pulse {
      background: #2a0044; color: #ff00ff; border-color: #bb00ff;
      box-shadow: 0 0 20px rgba(187,0,255,0.6);
      animation: pulsebox 1s infinite;
    }
    @keyframes pulsebox {
      0%,100% { box-shadow: 0 0 20px rgba(187,0,255,0.5); }
      50%      { box-shadow: 0 0 35px rgba(187,0,255,1);   }
    }

    #fire-btn {
      width: 130px; height: 130px; border-radius: 50%;
      background: rgba(255,40,40,0.1); border: 4px solid #ff3333;
      color: #ff3333; font-size: 18px; font-weight: bold;
      font-family: 'Courier New', monospace; letter-spacing: 3px;
      display: flex; flex-direction: column; align-items: center;
      justify-content: center; touch-action: none; user-select: none;
      flex-shrink: 0; transition: all 0.12s;
      box-shadow: 0 0 16px rgba(255,50,50,0.2);
    }
    #fire-btn .btn-sub { font-size: 9px; letter-spacing: 2px; color: #ff6666; margin-top: 2px; }
    #fire-btn.active { background: #ff3333; color: #000; box-shadow: 0 0 40px rgba(255,50,50,0.9); }
    #fire-btn.melee-mode { border-color: #00ff66; color: #00ff66; background: rgba(0,255,100,0.08); }
    #fire-btn.melee-mode.active { background: #00ff66; color: #000; box-shadow: 0 0 50px rgba(0,255,100,1); }

    /* ── GAME OVER SCREEN ─────────────────────────────────────────────── */
    #gameover-screen { gap: 20px; background: rgba(0,0,0,0.95); }
    #gameover-screen h1 { font-size: clamp(36px,10vw,64px); color: #ff0000; letter-spacing: 6px;
      text-shadow: 0 0 20px #ff0000; }
    #gameover-screen p  { font-size: 14px; color: #555; letter-spacing: 2px; }
    #restart-btn {
      width: 260px; height: 64px; font-size: 22px; font-weight: bold;
      background: #00ff00; color: #000; border: none; border-radius: 14px;
      letter-spacing: 3px; cursor: pointer; font-family: 'Courier New', monospace;
    }
    #restart-btn:active { transform: scale(0.95); }
    #restart-btn.voted  { background: #222; color: #555; }
    #vote-status { font-size: 16px; color: #00ff00; letter-spacing: 2px; min-height: 22px; }

    #status-bar {
      position: fixed; bottom: 4px; left: 50%; transform: translateX(-50%);
      font-size: 9px; color: #222; letter-spacing: 1px; z-index: 99;
    }

    @keyframes pulse { 0%,100%{opacity:1}50%{opacity:0.2} }
    @keyframes flash  { 0%,100%{opacity:1}50%{opacity:0.2} }
  </style>
</head>
<body>

  <!-- JOIN SCREEN -->
  <div id="join-screen" class="screen active">
    <h1>Z-TEAM</h1>
    <h2>REMOTE MULTIPLAYER</h2>
    <button id="new-room-btn">CREATE NEW ROOM</button>
    <div id="join-divider">OR JOIN WITH CODE</div>
    <input id="room-code-input" type="text" maxlength="4" placeholder="CODE" autocomplete="off">
    <button id="join-btn">JOIN ROOM</button>
    <div id="join-error"></div>
  </div>

  <!-- LOBBY SCREEN -->
  <div id="lobby-screen" class="screen">
    <div id="lobby-title">Z-TEAM</div>
    <div id="lobby-sub">REMOTE MULTIPLAYER</div>

    <div id="room-info">
      <div id="room-info-label">ROOM CODE</div>
      <div id="room-code-display">----</div>
      <button id="share-btn">SHARE INVITE LINK</button>
    </div>

    <div id="my-badge">PLAYER ?</div>

    <div id="player-list"></div>

    <button id="ready-btn">READY UP</button>
    <div id="waiting-text"></div>
  </div>

  <!-- GAME SCREEN -->
  <div id="game-screen" class="screen">
    <div id="canvas-wrap">
      <canvas id="game-canvas"></canvas>
    </div>
    <div id="hud-bar">
      <div id="hud-weapon">PISTOL</div>
      <div id="hud-wave">WAVE 1</div>
      <div id="hud-ammo">30</div>
      <div id="hud-points">0</div>
    </div>
    <div id="ctrl-area">
      <div id="joystick-zone"><div id="joystick-knob"></div></div>
      <button id="mystery-box-btn" disabled>MYSTERY<br>BOX<br>$950</button>
      <div id="fire-btn">FIRE<div class="btn-sub">HOLD</div></div>
    </div>
  </div>

  <!-- GAME OVER SCREEN -->
  <div id="gameover-screen" class="screen">
    <h1>GAME OVER</h1>
    <p>All players have fallen</p>
    <button id="restart-btn">RESTART</button>
    <div id="vote-status"></div>
  </div>

  <div id="status-bar">CONNECTING...</div>

  <script src="/socket.io/socket.io.js"></script>
  <script>

  // ================================================================
  // JOYSTICK
  // ================================================================
  class Joystick {
    constructor(zoneId, knobId) {
      this.zone = document.getElementById(zoneId);
      this.knob = document.getElementById(knobId);
      this.angle = null; this.active = false; this.maxR = 46;
      const o = { passive: false };
      this.zone.addEventListener('touchstart',  e => this.onStart(e), o);
      this.zone.addEventListener('touchmove',   e => this.onMove(e),  o);
      this.zone.addEventListener('touchend',    e => this.onEnd(e),   o);
      this.zone.addEventListener('touchcancel', e => this.onEnd(e),   o);
    }
    offset(e) {
      const r = this.zone.getBoundingClientRect();
      const s = e.touches ? e.touches[0] : e;
      return { x: s.clientX - r.left - r.width/2, y: s.clientY - r.top - r.height/2 };
    }
    onStart(e) { e.preventDefault(); this.active = true; this.onMove(e); }
    onMove(e) {
      if (!this.active) return; e.preventDefault();
      const { x, y } = this.offset(e);
      this.angle = Math.atan2(y, x);
      const c = Math.min(Math.sqrt(x*x+y*y), this.maxR);
      this.knob.style.transform = `translate(calc(-50% + ${Math.cos(this.angle)*c}px), calc(-50% + ${Math.sin(this.angle)*c}px))`;
    }
    onEnd(e) { e.preventDefault(); this.active = false; this.angle = null; this.knob.style.transform = 'translate(-50%,-50%)'; }
    getAngle() { return this.active ? this.angle : null; }
  }

  // ================================================================
  // CLIENT-SIDE RENDERER (draws server state onto canvas)
  // ================================================================
  class RemoteRenderer {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx    = canvas.getContext('2d');
      this.BASE_W = 1334; this.BASE_H = 750;
      this.mySlot = 1;
      this.particles = [];
      this.meleeFlashes = [];
      this.waveText = '';
      this.waveTextTimer = 0;
      this.resize();
      window.addEventListener('resize', () => this.resize());
    }

    resize() {
      const wrap  = document.getElementById('canvas-wrap');
      const W     = window.innerWidth;
      // Reserve 170px for controls + 36px for HUD bar
      const availH = window.innerHeight - 170 - 36;
      const scale  = Math.min(W / this.BASE_W, availH / this.BASE_H);
      this.scale   = scale;
      this.canvas.width  = this.BASE_W;
      this.canvas.height = this.BASE_H;
      this.canvas.style.width  = Math.floor(this.BASE_W * scale) + 'px';
      this.canvas.style.height = Math.floor(this.BASE_H * scale) + 'px';
      wrap.style.height = Math.floor(this.BASE_H * scale) + 'px';
    }

    showWaveText(text) {
      this.waveText = text; this.waveTextTimer = 120;
    }

    spawnParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1.5 + Math.random() * 4;
        const life  = 18 + Math.floor(Math.random() * 20);
        this.particles.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, color, life, maxLife: life, size: 2 + Math.random()*4 });
      }
    }

    spawnMeleeFlash(x, y, angle, color) {
      this.meleeFlashes.push({ x, y, angle, timer: 8, color });
    }

    render(state) {
      const ctx = this.ctx;
      const W = this.BASE_W, H = this.BASE_H;

      // Update particles
      for (let i = this.particles.length - 1; i >= 0; i--) {
        const p = this.particles[i];
        p.x += p.vx; p.y += p.vy; p.vx *= 0.92; p.vy *= 0.92; p.life--;
        if (p.life <= 0) this.particles.splice(i, 1);
      }
      for (let i = this.meleeFlashes.length - 1; i >= 0; i--) {
        this.meleeFlashes[i].timer--;
        if (this.meleeFlashes[i].timer <= 0) this.meleeFlashes.splice(i, 1);
      }
      if (this.waveTextTimer > 0) this.waveTextTimer--;

      // Spawn particles from server explosion events
      if (state.explosions) {
        for (let ex of state.explosions) {
          if (ex.melee) { this.spawnMeleeFlash(ex.x, ex.y, ex.angle, ex.color); }
          else          { this.spawnParticles(ex.x, ex.y, ex.color, ex.big ? 24 : 10); }
        }
      }

      // Background
      ctx.fillStyle = '#111'; ctx.fillRect(0, 0, W, H);

      // Grid
      ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 60) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for (let y = 0; y < H; y += 60) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

      // Border
      ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 4;
      ctx.strokeRect(2, 2, W-4, H-4);

      // Mystery box
      if (state.mysteryBox) {
        const b = state.mysteryBox;
        ctx.fillStyle = '#1a001a'; ctx.fillRect(b.x-18, b.y-18, 36, 36);
        ctx.strokeStyle = '#bb00ff'; ctx.lineWidth = 2; ctx.strokeRect(b.x-18, b.y-18, 36, 36);
        ctx.fillStyle = '#bb00ff'; ctx.font = 'bold 18px Courier New';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('?', b.x, b.y);
      }

      // Ammo packs
      for (let a of state.ammoPacks) {
        ctx.fillStyle = '#ffff00'; ctx.fillRect(a.x-10, a.y-10, 20, 20);
        ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 2; ctx.strokeRect(a.x-10, a.y-10, 20, 20);
        ctx.fillStyle = '#000'; ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('A', a.x, a.y);
      }

      // Health packs
      for (let h of state.healthPacks) {
        ctx.fillStyle = '#222'; ctx.fillRect(h.x-10, h.y-10, 20, 20);
        ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2; ctx.strokeRect(h.x-10, h.y-10, 20, 20);
        ctx.fillStyle = '#ff3333';
        ctx.fillRect(h.x-7, h.y-2, 14, 4);
        ctx.fillRect(h.x-2, h.y-7, 4, 14);
      }

      // Particles
      for (let pt of this.particles) {
        const alpha = pt.life / pt.maxLife;
        ctx.save(); ctx.globalAlpha = alpha;
        ctx.fillStyle = pt.color; ctx.shadowColor = pt.color; ctx.shadowBlur = 6;
        ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.size * alpha, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // Melee flashes
      for (let f of this.meleeFlashes) {
        ctx.save(); ctx.translate(f.x, f.y); ctx.rotate(f.angle);
        ctx.strokeStyle = f.color; ctx.lineWidth = 3; ctx.globalAlpha = f.timer / 8;
        ctx.beginPath(); ctx.arc(0, 0, 55, -Math.PI*0.3, Math.PI*0.3); ctx.stroke();
        ctx.restore();
      }

      // Zombies
      for (let z of state.zombies) {
        const hs = z.size/2;
        ctx.fillStyle = z.color; ctx.fillRect(z.x-hs, z.y-hs, z.size, z.size);
        ctx.strokeStyle = z.borderColor; ctx.lineWidth = 2; ctx.strokeRect(z.x-hs, z.y-hs, z.size, z.size);
        ctx.fillStyle = '#ff0000'; ctx.fillRect(z.x-hs, z.y-hs-8, z.size, 4);
        ctx.fillStyle = '#00ff00'; ctx.fillRect(z.x-hs, z.y-hs-8, z.size*(z.hp/z.maxHp), 4);
      }

      // Bullets
      for (let b of state.bullets) {
        ctx.fillStyle = b.color; ctx.shadowColor = b.color; ctx.shadowBlur = 8;
        ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Boss
      if (state.boss && !state.boss.dead) {
        const b = state.boss;
        const flashing = b.flashTimer > 0 && b.flashTimer % 2 === 0;
        ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(b.rotation);
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
          const a = -Math.PI/2 + i * (2*Math.PI/3);
          const px = Math.cos(a)*b.radius, py = Math.sin(a)*b.radius;
          i === 0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
        }
        ctx.closePath();
        ctx.fillStyle = flashing ? '#ffffff' : b.color;
        ctx.shadowColor = '#bb00ff'; ctx.shadowBlur = 30; ctx.fill();
        ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.stroke();
        ctx.shadowBlur = 0; ctx.restore();

        // Tips
        const tipAngles = [0,1,2].map(i => b.rotation - Math.PI/2 + i*(2*Math.PI/3));
        for (let t = 0; t < 3; t++) {
          if (b.tips[t].hp <= 0) continue;
          const tx = b.x + Math.cos(tipAngles[t])*b.radius;
          const ty = b.y + Math.sin(tipAngles[t])*b.radius;
          const tipFlash = b.flashTimer > 0 && b.flashTimer % 2 === 0;
          ctx.save(); ctx.translate(tx, ty); ctx.rotate(b.rotation + t*(2*Math.PI/3));
          ctx.beginPath(); ctx.moveTo(0,-20); ctx.lineTo(12,14); ctx.lineTo(-12,14); ctx.closePath();
          ctx.fillStyle = tipFlash ? '#ffffff' : '#ff00ff';
          ctx.shadowColor = '#ff00ff'; ctx.shadowBlur = 15; ctx.fill(); ctx.shadowBlur = 0;
          ctx.restore();
          ctx.fillStyle = '#440044'; ctx.fillRect(tx-18, ty-30, 36, 5);
          ctx.fillStyle = '#ff00ff'; ctx.fillRect(tx-18, ty-30, 36*(b.tips[t].hp/b.tips[t].maxHp), 5);
        }
      }

      // Players
      for (let p of state.players) {
        if (!p.connected) continue;
        const hs = 14;
        if (!p.alive) {
          ctx.globalAlpha = 0.3;
          ctx.fillStyle = p.color; ctx.fillRect(p.x-hs, p.y-hs, hs*2, hs*2);
          ctx.globalAlpha = 1; continue;
        }
        ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.angle);
        // Body
        ctx.fillStyle = p.color; ctx.shadowColor = p.color; ctx.shadowBlur = 10;
        ctx.fillRect(-hs, -hs, hs*2, hs*2);
        // Direction indicator
        ctx.fillStyle = '#000'; ctx.fillRect(4, -4, 12, 8);
        ctx.shadowBlur = 0; ctx.restore();
        // HP bar
        ctx.fillStyle = '#333'; ctx.fillRect(p.x-hs, p.y-hs-10, hs*2, 5);
        ctx.fillStyle = p.hp > 40 ? '#00ff00' : p.hp > 20 ? '#ffff00' : '#ff0000';
        ctx.fillRect(p.x-hs, p.y-hs-10, (hs*2)*(p.hp/p.maxHp), 5);
        // Points
        ctx.fillStyle = p.color; ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
        ctx.fillText('$'+p.points, p.x, p.y-hs-12);
        // Highlight my player
        if (p.slot === this.mySlot) {
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
          ctx.strokeRect(p.x-hs-3, p.y-hs-3, (hs+3)*2, (hs+3)*2);
          ctx.globalAlpha = 1;
        }
      }

      // Wave text banner
      if (this.waveTextTimer > 0) {
        const alpha = Math.min(1, this.waveTextTimer / 30);
        ctx.save(); ctx.globalAlpha = alpha;
        ctx.font = 'bold 48px Courier New'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillStyle = this.waveText.includes('BOSS') ? '#ff00ff' : '#00ff00';
        ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 30;
        ctx.fillText(this.waveText, W/2, H/2);
        ctx.shadowBlur = 0; ctx.restore();
      }

      // Wave number (top right)
      ctx.fillStyle = '#333'; ctx.font = '14px Courier New';
      ctx.textAlign = 'right'; ctx.textBaseline = 'top';
      ctx.fillText('WAVE ' + state.wave, W-12, 12);
    }
  }

  // ================================================================
  // REMOTE CLIENT
  // ================================================================
  class RemoteClient {
    constructor() {
      this.socket   = io({ transports: ['websocket'] });
      this.roomCode = null;
      this.slot     = null;
      this.color    = null;
      this.firing   = false;
      this.meleeing = false;
      this.inMeleeMode = false;
      this.isReady  = false;
      this.hasVoted = false;
      this.inputLoop = null;
      this.renderer = null;
      this.animFrame = null;
      this.lastState = null;
      this.joystick = new Joystick('joystick-zone', 'joystick-knob');
      this.fp = this.loadFP();

      this.bindSocket();
      this.bindJoinUI();
      this.bindLobbyUI();
      this.bindGameUI();
      this.bindGameoverUI();
      this.checkDeepLink();
    }

    loadFP() {
      let fp = sessionStorage.getItem('zt-fp');
      if (!fp) { fp = 'fp-'+Date.now()+'-'+Math.random().toString(36).slice(2); sessionStorage.setItem('zt-fp', fp); }
      return fp;
    }

    checkDeepLink() {
      const params = new URLSearchParams(window.location.search);
      const code   = params.get('room');
      if (code && code.length === 4) {
        document.getElementById('room-code-input').value = code.toUpperCase();
        setTimeout(() => this.joinRoom(code.toUpperCase()), 600);
      }
    }

    // ── Socket events ────────────────────────────────────────────────
    bindSocket() {
      this.socket.on('connect',    () => this.setStatus('CONNECTED'));
      this.socket.on('disconnect', () => this.setStatus('DISCONNECTED'));
      this.socket.on('ping',       () => this.socket.emit('pong'));

      this.socket.on('join-success', d => this.onJoinSuccess(d));
      this.socket.on('join-failed',  d => this.showError(d.reason));

      this.socket.on('lobby-update', d => this.updateLobby(d));

      this.socket.on('game-starting-remote', () => this.startGame());

      this.socket.on('remote-game-state', state => {
        this.lastState = state;
        if (this.renderer) this.renderer.render(state);
        this.updateHUD(state);
        if (state.gameOver) this.showScreen('gameover-screen');
      });

      this.socket.on('wave-event', d => {
        if (this.renderer) {
          this.renderer.showWaveText(d.type === 'boss' ? 'BOSS WAVE' : 'WAVE ' + d.wave);
        }
      });

      this.socket.on('game-over', () => this.showScreen('gameover-screen'));

      this.socket.on('restart-vote-update', d => {
        document.getElementById('vote-status').textContent = `Votes: ${d.votes} / ${d.needed}`;
      });

      this.socket.on('game-restarting-remote', () => {
        this.isReady = false; this.hasVoted = false;
        this.stopGame();
        this.showScreen('lobby-screen');
        const btn = document.getElementById('ready-btn');
        btn.textContent = 'READY UP'; btn.classList.remove('voted');
        document.getElementById('waiting-text').textContent = '';
      });

      this.socket.on('explosion', d => {
        if (this.renderer) this.renderer.spawnParticles(d.x, d.y, d.color);
      });
    }

    // ── Join UI ──────────────────────────────────────────────────────
    bindJoinUI() {
      document.getElementById('new-room-btn').addEventListener('click', () => {
        this.socket.emit('create-remote-room');
      });

      document.getElementById('join-btn').addEventListener('click', () => {
        const code = document.getElementById('room-code-input').value.trim().toUpperCase();
        if (code.length !== 4) { this.showError('Enter a 4-character code'); return; }
        this.joinRoom(code);
      });

      const input = document.getElementById('room-code-input');
      input.addEventListener('input',    e => { e.target.value = e.target.value.toUpperCase(); });
      input.addEventListener('keypress', e => { if (e.key === 'Enter') document.getElementById('join-btn').click(); });
    }

    joinRoom(code) {
      this.roomCode = code;
      this.socket.emit('join-room', { roomCode: code, deviceFingerprint: this.fp });
    }

    onJoinSuccess(data) {
      this.slot  = data.slotNumber;
      this.color = data.color;
      this.roomCode = data.roomCode;
      sessionStorage.setItem('zt-fp', data.deviceFingerprint);

      // Update lobby
      document.getElementById('room-code-display').textContent = this.roomCode;
      const badge = document.getElementById('my-badge');
      badge.textContent = 'PLAYER ' + this.slot;
      badge.style.color = this.color; badge.style.borderColor = this.color;

      this.showScreen('lobby-screen');
      this.setStatus('PLAYER ' + this.slot);
      this.requestWakeLock();
    }

    // ── Lobby UI ─────────────────────────────────────────────────────
    bindLobbyUI() {
      document.getElementById('share-btn').addEventListener('click', async () => {
        const url  = `${window.location.origin}/join/${this.roomCode}`;
        const btn  = document.getElementById('share-btn');
        if (navigator.share) {
          try {
            await navigator.share({ title: 'Z-TEAM', text: `Join my Z-TEAM game! Room: ${this.roomCode}`, url });
          } catch(e) {}
        } else {
          try {
            await navigator.clipboard.writeText(url);
            btn.textContent = 'LINK COPIED!'; btn.classList.add('copied');
            setTimeout(() => { btn.textContent = 'SHARE INVITE LINK'; btn.classList.remove('copied'); }, 2000);
          } catch(e) {}
        }
      });

      document.getElementById('ready-btn').addEventListener('click', () => {
        if (this.isReady) return;
        this.isReady = true;
        const btn = document.getElementById('ready-btn');
        btn.textContent = 'READY!'; btn.classList.add('voted');
        document.getElementById('waiting-text').textContent = 'Waiting for others...';
        this.socket.emit('player-ready', { roomCode: this.roomCode });
      });
    }

    updateLobby(data) {
      const list = document.getElementById('player-list');
      list.innerHTML = '';
      const slots = [1,2,3,4];
      for (let s of slots) {
        const p = data.players.find(p => p.slotNumber === s);
        const row = document.createElement('div');
        row.className = 'player-row' + (p && p.slotNumber === this.slot ? ' me' : '');
        if (p) {
          row.innerHTML = `<span class="pname" style="color:${p.color}">PLAYER ${p.slotNumber}${p.slotNumber === this.slot ? ' (YOU)' : ''}</span>
            <span class="pstatus ${p.ready ? 'ready' : ''}">${p.ready ? 'READY' : 'WAITING'}</span>`;
        } else {
          row.innerHTML = `<span class="pname" style="color:#333">PLAYER ${s}</span><span class="pstatus">OPEN</span>`;
        }
        list.appendChild(row);
      }
    }

    // ── Game UI ──────────────────────────────────────────────────────
    bindGameUI() {
      const fireBtn = document.getElementById('fire-btn');
      const press   = e => { e.preventDefault(); if (this.inMeleeMode) this.meleeing = true; else this.firing = true; fireBtn.classList.add('active'); };
      const release = e => { e.preventDefault(); this.firing = false; this.meleeing = false; fireBtn.classList.remove('active'); };
      fireBtn.addEventListener('touchstart',  press,   { passive: false });
      fireBtn.addEventListener('touchend',    release, { passive: false });
      fireBtn.addEventListener('touchcancel', release, { passive: false });

      document.getElementById('mystery-box-btn').addEventListener('click', () => {
        this.socket.emit('mystery-box-purchase', { roomCode: this.roomCode });
      });
    }

    startGame() {
      this.showScreen('game-screen');

      // Init renderer after layout settles
      setTimeout(() => {
        const canvas = document.getElementById('game-canvas');
        this.renderer = new RemoteRenderer(canvas);
        this.renderer.mySlot = this.slot;
      }, 100);

      // Input loop at 30Hz
      this.inputLoop = setInterval(() => {
        this.socket.emit('player-input', {
          roomCode: this.roomCode,
          input: { angle: this.joystick.getAngle(), fire: this.firing, melee: this.meleeing }
        });
      }, 33);
    }

    stopGame() {
      if (this.inputLoop) { clearInterval(this.inputLoop); this.inputLoop = null; }
      if (this.animFrame) { cancelAnimationFrame(this.animFrame); this.animFrame = null; }
    }

    updateHUD(state) {
      const p = state.players ? state.players[this.slot - 1] : null;
      if (!p) return;

      const ammo = p.ammo;
      const ammoEl = document.getElementById('hud-ammo');
      if (ammo === -1) { ammoEl.textContent = 'AMMO ∞'; ammoEl.className = ''; this.setMeleeMode(false); }
      else if (ammo === 0) { ammoEl.textContent = 'OUT'; ammoEl.className = 'empty'; this.setMeleeMode(true); }
      else {
        ammoEl.textContent = ammo;
        ammoEl.className = ammo <= 5 ? 'low' : '';
        this.setMeleeMode(false);
      }

      document.getElementById('hud-weapon').textContent = (p.weapon||'pistol').toUpperCase().replace('_',' ');
      document.getElementById('hud-points').textContent = '$'+p.points;
      document.getElementById('hud-wave').textContent   = 'WAVE '+state.wave;

      const boxBtn = document.getElementById('mystery-box-btn');
      if (p.canUseMysteryBox && p.points >= 950) {
        boxBtn.disabled = false; boxBtn.classList.add('pulse');
      } else {
        boxBtn.disabled = true; boxBtn.classList.remove('pulse');
      }
    }

    setMeleeMode(active) {
      if (this.inMeleeMode === active) return;
      this.inMeleeMode = active;
      const btn = document.getElementById('fire-btn');
      const sub = btn.querySelector('.btn-sub');
      if (active) { btn.classList.add('melee-mode'); btn.childNodes[0].textContent = 'KNIFE'; }
      else        { btn.classList.remove('melee-mode'); btn.childNodes[0].textContent = 'FIRE'; }
      if (active) this.firing = false; else this.meleeing = false;
    }

    // ── Game Over UI ─────────────────────────────────────────────────
    bindGameoverUI() {
      document.getElementById('restart-btn').addEventListener('click', () => {
        if (this.hasVoted) return;
        this.hasVoted = true;
        const btn = document.getElementById('restart-btn');
        btn.textContent = 'VOTED!'; btn.classList.add('voted');
        document.getElementById('vote-status').textContent = 'Waiting for others...';
        this.socket.emit('restart-vote-remote', { roomCode: this.roomCode });
      });
    }

    // ── Helpers ──────────────────────────────────────────────────────
    showScreen(id) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(id).classList.add('active');
      if (id === 'game-screen' && this.renderer) {
        setTimeout(() => this.renderer.resize(), 50);
      }
    }

    showError(msg) {
      const el = document.getElementById('join-error');
      el.textContent = msg;
      setTimeout(() => { el.textContent = ''; }, 3000);
    }

    setStatus(msg) { document.getElementById('status-bar').textContent = msg; }

    async requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          await navigator.wakeLock.request('screen');
          document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') {
              try { await navigator.wakeLock.request('screen'); } catch(_) {}
            }
          });
        }
      } catch(e) {}
    }
  }

  // Boot
  const client = new RemoteClient();
  document.body.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

  </script>
</body>
</html>
