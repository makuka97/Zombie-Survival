<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Z-TEAM Remote</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Courier New', monospace; color: #fff; touch-action: none; }
    .screen { display: none; position: fixed; inset: 0; flex-direction: column; align-items: center; justify-content: center; }
    .screen.active { display: flex; }

    /* JOIN */
    #join-screen { gap: 16px; background: #000; }
    #join-screen h1 { font-size: clamp(28px,8vw,48px); color: #00ff00; letter-spacing: 8px; text-shadow: 0 0 20px rgba(0,255,0,0.6); }
    #join-screen h2 { font-size: 12px; color: #333; letter-spacing: 4px; }
    #room-code-input { width: 200px; height: 56px; font-size: 30px; text-align: center; background: #000; border: 3px solid #00ff00; border-radius: 10px; color: #00ff00; letter-spacing: 10px; font-family: 'Courier New', monospace; }
    #join-btn { width: 200px; height: 50px; font-size: 18px; font-weight: bold; background: #00ff00; color: #000; border: none; border-radius: 10px; letter-spacing: 3px; cursor: pointer; font-family: 'Courier New', monospace; }
    #join-btn:active { transform: scale(0.95); }
    #new-room-btn { width: 200px; height: 50px; font-size: 14px; font-weight: bold; background: transparent; color: #00ff00; border: 2px solid #00ff00; border-radius: 10px; letter-spacing: 2px; cursor: pointer; font-family: 'Courier New', monospace; }
    #new-room-btn:active { background: rgba(0,255,0,0.1); }
    #join-divider { color: #333; font-size: 12px; letter-spacing: 3px; }
    #join-error { color: #ff4444; font-size: 13px; min-height: 18px; letter-spacing: 1px; }

    /* LOBBY */
    #lobby-screen { gap: 0; background: #000; justify-content: flex-start; padding: 40px 24px 24px; }
    #lobby-title { font-size: clamp(28px,8vw,48px); color: #00ff00; letter-spacing: 8px; text-shadow: 0 0 20px rgba(0,255,0,0.5); margin-bottom: 6px; }
    #lobby-sub { font-size: 11px; color: #333; letter-spacing: 4px; margin-bottom: 28px; }
    #room-info { width: 100%; max-width: 420px; background: #0a0a0a; border: 2px solid #1a1a1a; border-radius: 12px; padding: 18px 20px; margin-bottom: 20px; }
    #room-info-label { font-size: 10px; color: #444; letter-spacing: 3px; margin-bottom: 8px; }
    #room-code-display { font-size: 42px; color: #00ff00; letter-spacing: 12px; font-weight: bold; text-shadow: 0 0 15px rgba(0,255,0,0.5); margin-bottom: 14px; }
    #share-btn { width: 100%; height: 48px; font-size: 14px; font-weight: bold; background: #00ff00; color: #000; border: none; border-radius: 10px; letter-spacing: 2px; cursor: pointer; font-family: 'Courier New', monospace; }
    #share-btn:active { transform: scale(0.97); }
    #share-btn.copied { background: #00cc00; }
    #player-list { width: 100%; max-width: 420px; display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px; }
    .player-row { display: flex; align-items: center; justify-content: space-between; padding: 10px 16px; border-radius: 8px; background: #0a0a0a; border: 1px solid #1a1a1a; font-size: 14px; letter-spacing: 2px; }
    .player-row .pname { font-weight: bold; }
    .player-row .pstatus { font-size: 11px; color: #444; letter-spacing: 2px; }
    .player-row .pstatus.ready { color: #00ff00; }
    #my-badge { font-size: 18px; font-weight: bold; letter-spacing: 3px; padding: 10px 24px; border-radius: 10px; border: 2px solid; margin-bottom: 20px; text-align: center; }
    #ready-btn { width: 100%; max-width: 420px; height: 64px; font-size: 22px; font-weight: bold; background: #00ff00; color: #000; border: none; border-radius: 14px; letter-spacing: 4px; cursor: pointer; font-family: 'Courier New', monospace; box-shadow: 0 0 24px rgba(0,255,0,0.4); }
    #ready-btn:active { transform: scale(0.97); }
    #ready-btn.voted { background: #1a1a1a; color: #00ff00; border: 2px solid #00ff00; box-shadow: none; font-size: 16px; }
    #waiting-text { font-size: 12px; color: #555; letter-spacing: 2px; margin-top: 10px; animation: pulse 1.5s infinite; }

    /* GAME */
    #game-screen { flex-direction: column; background: #000; justify-content: flex-start; align-items: stretch; }
    #canvas-wrap { position: relative; flex-shrink: 0; width: 100%; background: #000; display: flex; align-items: center; justify-content: center; overflow: hidden; }
    #game-canvas { display: block; }
    #hud-bar { display: flex; justify-content: space-between; align-items: center; padding: 4px 16px; background: #050505; border-top: 1px solid #111; border-bottom: 1px solid #111; flex-shrink: 0; height: 36px; }
    #hud-weapon { font-size: 13px; color: #aaa; letter-spacing: 2px; }
    #hud-wave   { font-size: 13px; color: #555; letter-spacing: 2px; }
    #hud-ammo   { font-size: 15px; font-weight: bold; color: #ffff00; letter-spacing: 2px; }
    #hud-ammo.low   { color: #ff3333; animation: flash 0.5s infinite; }
    #hud-ammo.empty { color: #555; }
    #hud-points { font-size: 13px; color: #00ff00; letter-spacing: 2px; }
    #ctrl-area { height: 170px; flex-shrink: 0; display: flex; align-items: center; justify-content: space-between; padding: 0 28px; }
    #joystick-zone { width: 150px; height: 150px; border-radius: 50%; background: rgba(0,255,0,0.04); border: 3px solid #00ff00; position: relative; touch-action: none; flex-shrink: 0; }
    #joystick-zone::before, #joystick-zone::after { content: ''; position: absolute; background: rgba(0,255,0,0.12); }
    #joystick-zone::before { width:2px; height:100%; top:0; left:50%; transform:translateX(-50%); }
    #joystick-zone::after  { height:2px; width:100%; left:0; top:50%; transform:translateY(-50%); }
    #joystick-knob { width: 56px; height: 56px; border-radius: 50%; background: #00ff00; position: absolute; top:50%; left:50%; transform:translate(-50%,-50%); pointer-events: none; box-shadow: 0 0 16px rgba(0,255,0,0.8); }
    #mystery-box-btn { width: 90px; height: 90px; border-radius: 50%; background: #1a001a; color: #555; border: 3px solid #333; font-size: 10px; font-weight: bold; letter-spacing: 1px; font-family: 'Courier New', monospace; cursor: pointer; line-height: 1.4; flex-shrink: 0; transition: all 0.2s; }
    #mystery-box-btn:disabled { opacity: 0.4; }
    #mystery-box-btn.pulse { background: #2a0044; color: #ff00ff; border-color: #bb00ff; box-shadow: 0 0 20px rgba(187,0,255,0.6); animation: pulsebox 1s infinite; }
    @keyframes pulsebox { 0%,100% { box-shadow: 0 0 20px rgba(187,0,255,0.5); } 50% { box-shadow: 0 0 35px rgba(187,0,255,1); } }
    #fire-btn { width: 130px; height: 130px; border-radius: 50%; background: rgba(255,40,40,0.1); border: 4px solid #ff3333; color: #ff3333; font-size: 18px; font-weight: bold; font-family: 'Courier New', monospace; letter-spacing: 3px; display: flex; flex-direction: column; align-items: center; justify-content: center; touch-action: none; user-select: none; flex-shrink: 0; transition: all 0.12s; box-shadow: 0 0 16px rgba(255,50,50,0.2); }
    #fire-btn .btn-sub { font-size: 9px; letter-spacing: 2px; color: #ff6666; margin-top: 2px; }
    #fire-btn.active { background: #ff3333; color: #000; box-shadow: 0 0 40px rgba(255,50,50,0.9); }
    #fire-btn.melee-mode { border-color: #00ff66; color: #00ff66; background: rgba(0,255,100,0.08); }
    #fire-btn.melee-mode.active { background: #00ff66; color: #000; box-shadow: 0 0 50px rgba(0,255,100,1); }

    /* GAME OVER */
    #gameover-screen { gap: 20px; background: rgba(0,0,0,0.95); }
    #gameover-screen h1 { font-size: clamp(36px,10vw,64px); color: #ff0000; letter-spacing: 6px; text-shadow: 0 0 20px #ff0000; }
    #gameover-screen p  { font-size: 14px; color: #555; letter-spacing: 2px; }
    #restart-btn { width: 260px; height: 64px; font-size: 22px; font-weight: bold; background: #00ff00; color: #000; border: none; border-radius: 14px; letter-spacing: 3px; cursor: pointer; font-family: 'Courier New', monospace; }
    #restart-btn:active { transform: scale(0.95); }
    #restart-btn.voted  { background: #222; color: #555; }
    #vote-status { font-size: 16px; color: #00ff00; letter-spacing: 2px; min-height: 22px; }

    #ping-display { position: fixed; top: 4px; right: 8px; font-size: 9px; color: #333; z-index: 99; }
    #status-bar { position: fixed; bottom: 4px; left: 50%; transform: translateX(-50%); font-size: 9px; color: #222; letter-spacing: 1px; z-index: 99; }

    @keyframes pulse { 0%,100%{opacity:1}50%{opacity:0.2} }
    @keyframes flash  { 0%,100%{opacity:1}50%{opacity:0.2} }
  </style>
</head>
<body>

  <div id="join-screen" class="screen active">
    <h1>Z-TEAM</h1>
    <h2>REMOTE MULTIPLAYER</h2>
    <button id="new-room-btn">CREATE NEW ROOM</button>
    <div id="join-divider">OR JOIN WITH CODE</div>
    <input id="room-code-input" type="text" maxlength="4" placeholder="CODE" autocomplete="off">
    <button id="join-btn">JOIN ROOM</button>
    <div id="join-error"></div>
  </div>

  <div id="lobby-screen" class="screen">
    <div id="lobby-title">Z-TEAM</div>
    <div id="lobby-sub">REMOTE MULTIPLAYER</div>
    <div id="room-info">
      <div id="room-info-label">ROOM CODE</div>
      <div id="room-code-display">----</div>
      <button id="share-btn">SHARE INVITE LINK</button>
    </div>
    <div id="my-badge">PLAYER ?</div>
    <div id="player-list"></div>
    <button id="ready-btn">READY UP</button>
    <div id="waiting-text"></div>
  </div>

  <div id="game-screen" class="screen">
    <div id="canvas-wrap"><canvas id="game-canvas"></canvas></div>
    <div id="hud-bar">
      <div id="hud-weapon">PISTOL</div>
      <div id="hud-wave">WAVE 1</div>
      <div id="hud-ammo">30</div>
      <div id="hud-points">$0</div>
    </div>
    <div id="ctrl-area">
      <div id="joystick-zone"><div id="joystick-knob"></div></div>
      <button id="mystery-box-btn" disabled>MYSTERY<br>BOX<br>$950</button>
      <div id="fire-btn">FIRE<div class="btn-sub">HOLD</div></div>
    </div>
  </div>

  <div id="gameover-screen" class="screen">
    <h1>GAME OVER</h1>
    <p>All players have fallen</p>
    <button id="restart-btn">RESTART</button>
    <div id="vote-status"></div>
  </div>

  <div id="ping-display">-- ms</div>
  <div id="status-bar">CONNECTING...</div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
  'use strict';

  // ── Shared constants (must match server) ─────────────────────────
  const PLAYER_SPEED = 1.25; // halved — server now runs at 60Hz
  const PLAYER_SIZE  = 28;
  const BULLET_SPEED = 4;   // halved — server now runs at 60Hz
  const CANVAS_W     = 1334;
  const CANVAS_H     = 750;
  const WALL_PAD     = PLAYER_SIZE / 2 + 6;
  const PRED_CORRECT = 0.15;   // lerp strength toward server position per frame (lower = smoother)
  const SNAP_DIST    = 100;    // px — snap if correction gap is this large

  const WEAPON_FIRE_RATES = {
    pistol: 10, smg: 5, shotgun: 20, ar: 7, lmg: 8, raygun: 12, thundergun: 30
  };

  // ================================================================
  // JOYSTICK
  // ================================================================
  class Joystick {
    constructor(zoneId, knobId) {
      this.zone  = document.getElementById(zoneId);
      this.knob  = document.getElementById(knobId);
      this.angle = null; this.active = false; this.maxR = 46;
      const o = { passive: false };
      this.zone.addEventListener('touchstart',  e => this.onStart(e), o);
      this.zone.addEventListener('touchmove',   e => this.onMove(e),  o);
      this.zone.addEventListener('touchend',    e => this.onEnd(e),   o);
      this.zone.addEventListener('touchcancel', e => this.onEnd(e),   o);
    }
    offset(e) {
      const r = this.zone.getBoundingClientRect();
      const s = e.touches ? e.touches[0] : e;
      return { x: s.clientX - r.left - r.width/2, y: s.clientY - r.top - r.height/2 };
    }
    onStart(e) { e.preventDefault(); this.active = true; this.onMove(e); }
    onMove(e) {
      if (!this.active) return; e.preventDefault();
      const { x, y } = this.offset(e);
      this.angle = Math.atan2(y, x);
      const c = Math.min(Math.sqrt(x*x+y*y), this.maxR);
      this.knob.style.transform = `translate(calc(-50% + ${Math.cos(this.angle)*c}px), calc(-50% + ${Math.sin(this.angle)*c}px))`;
    }
    onEnd(e) { e.preventDefault(); this.active = false; this.angle = null; this.knob.style.transform = 'translate(-50%,-50%)'; }
    getAngle() { return this.active ? this.angle : null; }
  }

  // ================================================================
  // CLIENT-SIDE PREDICTION ENGINE
  // Runs our player locally at 60 fps so movement feels instant.
  // Server state reconciles the position smoothly every ~33ms.
  // ================================================================
  class Prediction {
    constructor(slot, color) {
      this.slot    = slot;
      this.color   = color;
      this.x       = 80;
      this.y       = 80;
      this.angle   = 0;
      this.alive   = true;
      this.hp      = 100;
      this.maxHp   = 100;
      this.seeded  = false;
      this.fireRate = 10;
      this.fireCd   = 0;
      this.bullets  = []; // local predicted bullets (visual only)
    }

    // Called once when first server state arrives
    seed(sp) {
      this.x = sp.x; this.y = sp.y; this.angle = sp.angle;
      this.alive = sp.alive; this.hp = sp.hp; this.maxHp = sp.maxHp;
      this.seeded = true;
    }

    // 60Hz local tick — runs physics locally for zero-latency feel
    tick(joystickAngle, firing, inMeleeMode) {
      // Move
      if (joystickAngle !== null && this.alive) {
        this.angle = joystickAngle;
        this.x = Math.max(WALL_PAD, Math.min(CANVAS_W - WALL_PAD, this.x + Math.cos(joystickAngle) * PLAYER_SPEED));
        this.y = Math.max(WALL_PAD, Math.min(CANVAS_H - WALL_PAD, this.y + Math.sin(joystickAngle) * PLAYER_SPEED));
      }

      // Fire predicted bullets (visual only — damage handled server side)
      this.fireCd--;
      if (firing && !inMeleeMode && this.alive && this.fireCd <= 0) {
        this.bullets.push({
          x: this.x + Math.cos(this.angle) * PLAYER_SIZE,
          y: this.y + Math.sin(this.angle) * PLAYER_SIZE,
          vx: Math.cos(this.angle) * BULLET_SPEED,
          vy: Math.sin(this.angle) * BULLET_SPEED,
          life: 55, color: this.color
        });
        this.fireCd = this.fireRate;
      }

      // Advance predicted bullets
      for (let i = this.bullets.length - 1; i >= 0; i--) {
        const b = this.bullets[i];
        b.x += b.vx; b.y += b.vy; b.life--;
        if (b.life <= 0 || b.x < 0 || b.x > CANVAS_W || b.y < 0 || b.y > CANVAS_H)
          this.bullets.splice(i, 1);
      }
    }

    // Called each time server state arrives — smooth correction
    reconcile(sp) {
      // Always sync non-positional state from server (hp, alive)
      this.alive = sp.alive;
      this.hp    = sp.hp;
      this.maxHp = sp.maxHp;

      if (!this.alive) { this.x = sp.x; this.y = sp.y; return; }

      const dx   = sp.x - this.x;
      const dy   = sp.y - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist > SNAP_DIST) {
        // Large correction — snap instantly (shouldn't happen often)
        this.x = sp.x; this.y = sp.y;
      } else if (dist > 1.5) {
        // Small drift — lerp smoothly so it's invisible to the player
        this.x += dx * PRED_CORRECT;
        this.y += dy * PRED_CORRECT;
      }
    }

    // Remove predicted bullets near a confirmed server hit
    clearNear(x, y) {
      this.bullets = this.bullets.filter(b => Math.sqrt((b.x-x)**2+(b.y-y)**2) > 60);
    }
  }

  // ================================================================
  // INTERPOLATOR — smooths other players + zombies between server ticks
  // Server runs at 30Hz (33ms), we render at 60Hz (16ms).
  // Each entity glides from its previous position to its new one
  // over exactly one server tick duration — looks perfectly smooth.
  // ================================================================
  class Interpolator {
    constructor() {
      this.players    = new Map();
      this.zombies    = [];
      this._snapshots = [];

      // ── Adaptive jitter buffer ─────────────────────────────────────
      // Measures real packet arrival jitter and sets buffer just large
      // enough to always have a prev+next pair, minimising lag.
      this._minBuffer  = 16;   // ms — floor (1 server tick at 60Hz)
      this._maxBuffer  = 150;  // ms — ceiling for very bad connections
      this.BUFFER      = 50;   // ms — starting value, self-tunes
      this._lastArrival = 0;
      this._jitterSamples = [];
    }

    _updateJitter(now) {
      if (this._lastArrival > 0) {
        const interval = now - this._lastArrival;
        const expected = 1000 / 60; // 16ms
        const jitter   = Math.abs(interval - expected);
        this._jitterSamples.push(jitter);
        if (this._jitterSamples.length > 20) this._jitterSamples.shift();
        // Buffer = 2 ticks + average jitter, clamped
        const avgJitter = this._jitterSamples.reduce((a,b) => a+b, 0) / this._jitterSamples.length;
        this.BUFFER = Math.min(this._maxBuffer, Math.max(this._minBuffer, (1000/60)*2 + avgJitter));
      }
      this._lastArrival = now;
    }

    onServerState(state, mySlot) {
      const now = Date.now();
      this._updateJitter(now);

      // ── Players ────────────────────────────────────────────────────
      for (const sp of state.players) {
        if (sp.slot === mySlot) continue;
        if (!sp.connected) { this.players.delete(sp.slot); continue; }
        let p = this.players.get(sp.slot);
        if (!p) {
          p = { snapshots: [], x: sp.x, y: sp.y, angle: sp.angle,
                vx: 0, vy: 0,  // velocity for dead reckoning
                alive: sp.alive, hp: sp.hp, maxHp: sp.maxHp,
                points: sp.points, color: sp.color, slot: sp.slot };
          this.players.set(sp.slot, p);
        }
        // Compute velocity from last snapshot for dead reckoning
        const last = p.snapshots[p.snapshots.length - 1];
        if (last) {
          const dt = now - last.t;
          p.vx = dt > 0 ? (sp.x - last.x) / dt : 0;
          p.vy = dt > 0 ? (sp.y - last.y) / dt : 0;
        }
        p.snapshots.push({ t: now, x: sp.x, y: sp.y, angle: sp.angle,
                           alive: sp.alive, hp: sp.hp, maxHp: sp.maxHp,
                           points: sp.points, color: sp.color });
        if (p.snapshots.length > 20) p.snapshots.shift();
        p.alive = sp.alive; p.hp = sp.hp; p.maxHp = sp.maxHp;
        p.points = sp.points; p.color = sp.color;
      }
      for (const [slot] of this.players) {
        if (!state.players.find(p => p.slot === slot)) this.players.delete(slot);
      }

      // ── Zombies ────────────────────────────────────────────────────
      // Compute per-zombie velocities for dead reckoning
      const prevSnap = this._snapshots[this._snapshots.length - 1];
      const zombiesWithVel = state.zombies.map((z, i) => {
        const prev = prevSnap && prevSnap.zombies[i];
        const dt   = prevSnap ? (now - prevSnap.t) : 0;
        return { ...z,
          vx: (prev && dt > 0) ? (z.x - prev.x) / dt : 0,
          vy: (prev && dt > 0) ? (z.y - prev.y) / dt : 0
        };
      });
      this._snapshots.push({ t: now, zombies: zombiesWithVel });
      if (this._snapshots.length > 20) this._snapshots.shift();
    }

    _findFrame(snaps, renderTime) {
      if (renderTime <= snaps[0].t) return [snaps[0], snaps[0], false];
      if (renderTime >= snaps[snaps.length - 1].t) {
        const a = snaps[snaps.length - 2] || snaps[0];
        const b = snaps[snaps.length - 1];
        return [a, b, true]; // true = extrapolating (dead reckoning)
      }
      for (let i = 0; i < snaps.length - 1; i++) {
        if (snaps[i].t <= renderTime && snaps[i+1].t >= renderTime)
          return [snaps[i], snaps[i+1], false];
      }
      return [snaps[snaps.length-2] || snaps[0], snaps[snaps.length-1], true];
    }

    _lerpVal(a, b, t) { return a + (b - a) * t; }

    tick() {
      const renderTime = Date.now() - this.BUFFER;

      // ── Players ───────────────────────────────────────────────────
      for (const [, p] of this.players) {
        if (!p.snapshots.length) continue;
        const [prev, next, extrapolating] = this._findFrame(p.snapshots, renderTime);
        const span = next.t - prev.t;

        if (extrapolating) {
          // Dead reckoning — keep moving in last known direction
          const dt = renderTime - next.t; // ms past last known snapshot
          p.x = next.x + p.vx * dt;
          p.y = next.y + p.vy * dt;
          p.angle = next.angle; // hold last angle
        } else {
          const t = span > 0 ? (renderTime - prev.t) / span : 1;
          p.x = this._lerpVal(prev.x, next.x, t);
          p.y = this._lerpVal(prev.y, next.y, t);
          let da = next.angle - prev.angle;
          while (da >  Math.PI) da -= Math.PI * 2;
          while (da < -Math.PI) da += Math.PI * 2;
          p.angle = prev.angle + da * t;
        }
      }

      // ── Zombies ───────────────────────────────────────────────────
      if (!this._snapshots.length) return;
      const [prev, next, extrapolating] = this._findFrame(this._snapshots, renderTime);
      const span = next.t - prev.t;

      if (extrapolating) {
        // Dead reckoning — each zombie keeps moving in its last direction
        const dt = renderTime - next.t;
        this.zombies = next.zombies.map(z => ({
          ...z,
          x: z.x + z.vx * dt,
          y: z.y + z.vy * dt
        }));
      } else {
        const t = span > 0 ? (renderTime - prev.t) / span : 1;
        this.zombies = next.zombies.map((zNext, i) => {
          const zPrev = prev.zombies[i];
          if (!zPrev) return zNext;
          return { ...zNext,
            x: this._lerpVal(zPrev.x, zNext.x, t),
            y: this._lerpVal(zPrev.y, zNext.y, t)
          };
        });
      }
    }

    getPlayer(slot) { return this.players.get(slot) || null; }
  }

  // ================================================================
  // RENDERER — draws server state + local prediction at 60fps
  // ================================================================
  class Renderer {
    constructor(canvas) {
      this.canvas    = canvas;
      this.ctx       = canvas.getContext('2d');
      this.BASE_W    = CANVAS_W;
      this.BASE_H    = CANVAS_H;
      this.particles = [];
      this.melees    = [];
      this.waveText  = '';
      this.waveTimer = 0;
      // Don't resize in constructor — canvas may not be visible yet.
      // startGame() calls resize() explicitly after screen is shown.
      window.addEventListener('resize', () => this.resize());
    }

    resize() {
      const W      = window.innerWidth;
      const availH = window.innerHeight - 170 - 36;
      const scale  = Math.min(W / this.BASE_W, availH / this.BASE_H);
      this.canvas.width  = this.BASE_W;
      this.canvas.height = this.BASE_H;
      this.canvas.style.width  = Math.floor(this.BASE_W * scale) + 'px';
      this.canvas.style.height = Math.floor(this.BASE_H * scale) + 'px';
      document.getElementById('canvas-wrap').style.height = Math.floor(this.BASE_H * scale) + 'px';
    }

    showWave(text) { this.waveText = text; this.waveTimer = 150; }

    spawnParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2, s = 1.5 + Math.random()*4, l = 18 + Math.random()*20|0;
        this.particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, color, life: l, maxLife: l, size: 2+Math.random()*4 });
      }
    }

    // state      = latest server snapshot
    // pred       = Prediction instance (our player + local bullets)
    // mySlot     = which slot is us
    draw(state, pred, mySlot, interp) {
      const ctx = this.ctx, W = this.BASE_W, H = this.BASE_H;

      // Tick particles + effects
      for (let i = this.particles.length-1; i >= 0; i--) {
        const p = this.particles[i];
        p.x += p.vx; p.y += p.vy; p.vx *= 0.92; p.vy *= 0.92; p.life--;
        if (p.life <= 0) this.particles.splice(i, 1);
      }
      for (let i = this.melees.length-1; i >= 0; i--) {
        if (--this.melees[i].timer <= 0) this.melees.splice(i, 1);
      }
      if (this.waveTimer > 0) this.waveTimer--;

      // Consume server explosion events — clear after processing so they don't replay
      if (state.explosions && state.explosions.length) {
        for (const ex of state.explosions) {
          if (ex.melee) this.melees.push({ x: ex.x, y: ex.y, angle: ex.angle, color: ex.color, timer: 8 });
          else          this.spawnParticles(ex.x, ex.y, ex.color, ex.big ? 24 : 10);
          if (pred)     pred.clearNear(ex.x, ex.y);
        }
        state.explosions = []; // consumed — don't replay next frame
      }

      // ── Background ────────────────────────────────────────────────
      ctx.fillStyle = '#111'; ctx.fillRect(0, 0, W, H);
      ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 60) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for (let y = 0; y < H; y += 60) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

      // ── Mystery box ───────────────────────────────────────────────
      if (state.mysteryBox) {
        const b = state.mysteryBox;
        ctx.fillStyle = '#1a001a'; ctx.fillRect(b.x-18, b.y-18, 36, 36);
        ctx.strokeStyle = '#bb00ff'; ctx.lineWidth = 2; ctx.strokeRect(b.x-18, b.y-18, 36, 36);
        ctx.fillStyle = '#bb00ff'; ctx.font = 'bold 18px Courier New';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('?', b.x, b.y);
      }

      // ── Ammo packs ────────────────────────────────────────────────
      for (const a of state.ammoPacks) {
        ctx.fillStyle = '#ffff00'; ctx.fillRect(a.x-10, a.y-10, 20, 20);
        ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 2; ctx.strokeRect(a.x-10, a.y-10, 20, 20);
        ctx.fillStyle = '#000'; ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('A', a.x, a.y);
      }

      // ── Health packs ──────────────────────────────────────────────
      for (const h of state.healthPacks) {
        ctx.fillStyle = '#222'; ctx.fillRect(h.x-10, h.y-10, 20, 20);
        ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2; ctx.strokeRect(h.x-10, h.y-10, 20, 20);
        ctx.fillStyle = '#ff3333'; ctx.fillRect(h.x-7, h.y-2, 14, 4); ctx.fillRect(h.x-2, h.y-7, 4, 14);
      }

      // ── Particles ─────────────────────────────────────────────────
      for (const pt of this.particles) {
        const a = pt.life / pt.maxLife;
        ctx.save(); ctx.globalAlpha = a;
        ctx.fillStyle = pt.color; ctx.shadowColor = pt.color; ctx.shadowBlur = 6;
        ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.size*a, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // ── Melee flashes ─────────────────────────────────────────────
      for (const f of this.melees) {
        ctx.save(); ctx.globalAlpha = f.timer/8;
        ctx.strokeStyle = f.color; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(f.x, f.y, 55, f.angle-Math.PI*0.3, f.angle+Math.PI*0.3); ctx.stroke();
        ctx.restore();
      }

      // ── Zombies (interpolated) ───────────────────────────────────
      const zombiesToDraw = interp ? interp.zombies : state.zombies;
      for (const z of zombiesToDraw) {
        const hs = z.size/2;
        ctx.fillStyle = z.color; ctx.fillRect(z.x-hs, z.y-hs, z.size, z.size);
        ctx.strokeStyle = z.borderColor; ctx.lineWidth = 2; ctx.strokeRect(z.x-hs, z.y-hs, z.size, z.size);
        ctx.fillStyle = '#ff0000'; ctx.fillRect(z.x-hs, z.y-hs-8, z.size, 4);
        ctx.fillStyle = '#00ff00'; ctx.fillRect(z.x-hs, z.y-hs-8, z.size*(z.hp/z.maxHp), 4);
      }

      // ── Bullets ──────────────────────────────────────────────────
      // Draw server bullets for ALL players (authoritative positions)
      // For our own slot: skip server bullets and show predicted instead (zero latency)
      const myColor = pred ? pred.color : null;
      if (state.bullets) {
        for (const b of state.bullets) {
          // If this bullet matches our color, skip — we draw predicted version instead
          if (b.color === myColor) continue;
          ctx.fillStyle = b.color; ctx.shadowColor = b.color; ctx.shadowBlur = 8;
          ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
      // Our predicted bullets (instant feel)
      if (pred) {
        for (const b of pred.bullets) {
          ctx.fillStyle = b.color; ctx.shadowColor = b.color; ctx.shadowBlur = 8;
          ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      // ── Boss (all 6 types) ────────────────────────────────────────
      if (state.boss && !state.boss.dead) {
        const b = state.boss;
        const flash = b.flashTimer > 0 && b.flashTimer % 2 === 0;

        // Boss bullets (shared across all types)
        if (b.bossBullets) {
          for (const bb of b.bossBullets) {
            ctx.save(); ctx.fillStyle = bb.color; ctx.shadowColor = bb.color; ctx.shadowBlur = 10;
            ctx.beginPath(); ctx.arc(bb.x, bb.y, 5, 0, Math.PI*2); ctx.fill(); ctx.restore();
          }
        }

        if (b.type === 'triangle') {
          ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(b.rotation);
          ctx.beginPath();
          for (let i = 0; i < 3; i++) { const a=-Math.PI/2+i*(2*Math.PI/3); i===0?ctx.moveTo(Math.cos(a)*b.radius,Math.sin(a)*b.radius):ctx.lineTo(Math.cos(a)*b.radius,Math.sin(a)*b.radius); }
          ctx.closePath(); ctx.fillStyle=flash?'#ffffff':b.color; ctx.shadowColor='#bb00ff'; ctx.shadowBlur=30; ctx.fill();
          ctx.strokeStyle='#000'; ctx.lineWidth=4; ctx.stroke(); ctx.shadowBlur=0; ctx.restore();
          if (b.tips) { const tipAngles=[0,1,2].map(i=>b.rotation-Math.PI/2+i*(2*Math.PI/3));
            for (let t=0;t<3;t++) { if(b.tips[t].hp<=0)continue; const tx=b.x+Math.cos(tipAngles[t])*b.radius,ty=b.y+Math.sin(tipAngles[t])*b.radius;
              ctx.save(); ctx.translate(tx,ty); ctx.rotate(b.rotation+t*(2*Math.PI/3));
              ctx.beginPath(); ctx.moveTo(0,-20); ctx.lineTo(12,14); ctx.lineTo(-12,14); ctx.closePath();
              ctx.fillStyle=flash?'#ffffff':'#cc0000'; ctx.shadowColor='#ff0000'; ctx.shadowBlur=15; ctx.fill(); ctx.shadowBlur=0; ctx.restore();
              ctx.fillStyle='#330000'; ctx.fillRect(tx-20,ty+22,40,5);
              ctx.fillStyle='#ff0000'; ctx.fillRect(tx-20,ty+22,40*(b.tips[t].hp/b.tips[t].maxHp),5);
            }
          }

        } else if (b.type === 'octagon') {
          ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.rotation);
          ctx.beginPath(); for(let i=0;i<8;i++){const a=(i/8)*Math.PI*2;i===0?ctx.moveTo(Math.cos(a)*b.radius,Math.sin(a)*b.radius):ctx.lineTo(Math.cos(a)*b.radius,Math.sin(a)*b.radius);}
          ctx.closePath(); ctx.fillStyle=flash?'#ffffff':'#cc4400'; ctx.shadowColor='#ff6600'; ctx.shadowBlur=25; ctx.fill();
          ctx.strokeStyle='#ff9900'; ctx.lineWidth=3; ctx.stroke(); ctx.shadowBlur=0; ctx.restore();
          if (b.corners) { for(let i=0;i<8;i++){if(b.corners[i].hp<=0)continue; const a=b.rotation+(i/8)*Math.PI*2,cx=b.x+Math.cos(a)*b.radius,cy=b.y+Math.sin(a)*b.radius,r=8+(b.corners[i].hp/b.corners[i].maxHp)*6;
            ctx.save(); ctx.fillStyle=flash?'#fff':'#ff4400'; ctx.shadowColor='#ff6600'; ctx.shadowBlur=12;
            ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.restore();
          }}

        } else if (b.type === 'pentagon') {
          ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.rotation);
          if (b.panels) { for(let i=0;i<5;i++){if(b.panels[i].hp<=0)continue; const aS=(i/5)*Math.PI*2-Math.PI/2,aE=((i+1)/5)*Math.PI*2-Math.PI/2,hr=b.panels[i].hp/b.panels[i].maxHp;
            ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,b.radius,aS+0.2,aE-0.2); ctx.closePath();
            ctx.fillStyle=flash?'#ffffff':`rgba(0,${Math.floor(100+100*hr)},255,0.8)`; ctx.shadowColor='#00aaff'; ctx.shadowBlur=20; ctx.fill();
            ctx.strokeStyle='#0055ff'; ctx.lineWidth=2; ctx.stroke();
          }}
          ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); ctx.fillStyle=flash?'#ffffff':'#003388'; ctx.shadowBlur=0; ctx.fill(); ctx.restore();

        } else if (b.type === 'diamond') {
          if (!b.split) {
            const hr=b.coreHp/b.coreMaxHp;
            ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.rotation);
            ctx.beginPath(); ctx.moveTo(0,-b.radius); ctx.lineTo(b.radius*0.6,0); ctx.lineTo(0,b.radius); ctx.lineTo(-b.radius*0.6,0); ctx.closePath();
            ctx.fillStyle=flash?'#ffffff':`hsl(${320+40*hr},100%,50%)`; ctx.shadowColor='#ff44aa'; ctx.shadowBlur=30; ctx.fill();
            ctx.strokeStyle='#ff88cc'; ctx.lineWidth=3; ctx.stroke(); ctx.shadowBlur=0;
            ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(-30,-5,60,10);
            ctx.fillStyle='#ff44aa'; ctx.fillRect(-30,-5,60*hr,10); ctx.restore();
          } else if (b.shards) {
            for (const s of b.shards) { if(!s.alive)continue;
              ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.rotation);
              ctx.beginPath(); ctx.moveTo(0,-s.radius); ctx.lineTo(s.radius*0.6,0); ctx.lineTo(0,s.radius); ctx.lineTo(-s.radius*0.6,0); ctx.closePath();
              ctx.fillStyle=flash?'#ffffff':'#cc2288'; ctx.shadowColor='#ff44aa'; ctx.shadowBlur=20; ctx.fill();
              ctx.strokeStyle='#ff88cc'; ctx.lineWidth=2; ctx.stroke(); ctx.shadowBlur=0;
              const bw=s.radius*1.2; ctx.fillStyle='#330011'; ctx.fillRect(-bw/2,s.radius+4,bw,4);
              ctx.fillStyle='#ff44aa'; ctx.fillRect(-bw/2,s.radius+4,bw*(s.hp/s.maxHp),4); ctx.restore();
            }
          }

        } else if (b.type === 'spiral') {
          ctx.save(); ctx.translate(b.x,b.y);
          if (b.arms) { for(let i=0;i<5;i++){if(b.arms[i].hp<=0)continue; const armA=b.rotation+(i/5)*Math.PI*2,ext=b.radius+60+Math.sin((b.breathe||0)+i)*30,hr=b.arms[i].hp/b.arms[i].maxHp;
            ctx.save(); ctx.strokeStyle=flash?'#ffffff':`hsl(150,100%,${40+30*hr}%)`; ctx.lineWidth=6+(1-hr)*4; ctx.shadowColor='#44ffaa'; ctx.shadowBlur=15;
            ctx.beginPath(); const midA=armA+0.4; ctx.moveTo(0,0); ctx.quadraticCurveTo(Math.cos(midA)*ext*0.6,Math.sin(midA)*ext*0.6,Math.cos(armA)*ext,Math.sin(armA)*ext); ctx.stroke(); ctx.restore();
            const tipX=Math.cos(armA)*ext,tipY=Math.sin(armA)*ext;
            ctx.save(); ctx.fillStyle=flash?'#fff':'#00ff88'; ctx.shadowColor='#44ffaa'; ctx.shadowBlur=20;
            ctx.beginPath(); ctx.arc(tipX,tipY,8+hr*6,0,Math.PI*2); ctx.fill(); ctx.restore();
            ctx.fillStyle='#003311'; ctx.fillRect(tipX-20,tipY+16,40,4);
            ctx.fillStyle='#44ffaa'; ctx.fillRect(tipX-20,tipY+16,40*hr,4);
          }}
          ctx.beginPath(); ctx.arc(0,0,25,0,Math.PI*2); ctx.fillStyle=flash?'#ffffff':'#006633'; ctx.shadowColor='#44ffaa'; ctx.shadowBlur=20; ctx.fill(); ctx.restore();

        } else if (b.type === 'fractal') {
          if (b.pieces) { for(const piece of b.pieces){if(!piece.alive)continue; const hr=piece.hp/piece.maxHp;
            ctx.save(); ctx.translate(piece.x,piece.y); ctx.rotate(piece.rotation);
            ctx.beginPath(); for(let i=0;i<3;i++){const a=-Math.PI/2+i*(2*Math.PI/3);i===0?ctx.moveTo(Math.cos(a)*piece.radius,Math.sin(a)*piece.radius):ctx.lineTo(Math.cos(a)*piece.radius,Math.sin(a)*piece.radius);}
            ctx.closePath(); ctx.fillStyle=flash?'#ffffff':`hsl(50,100%,${30+30*hr}%)`; ctx.shadowColor='#ffdd00'; ctx.shadowBlur=20; ctx.fill();
            ctx.strokeStyle='#ffaa00'; ctx.lineWidth=2; ctx.stroke(); ctx.shadowBlur=0;
            const bw=piece.radius*1.4; ctx.fillStyle='#332200'; ctx.fillRect(-bw/2,piece.radius+4,bw,4);
            ctx.fillStyle='#ffdd00'; ctx.fillRect(-bw/2,piece.radius+4,bw*hr,4); ctx.restore();
          }}
        }

        // Boss label
        ctx.fillStyle = '#ff44ff'; ctx.font = 'bold 16px Courier New';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(b.label || 'BOSS', b.x, b.y - (b.radius||80) - 20);
      }

      // ── Players ───────────────────────────────────────────────────
      for (const sp of state.players) {
        const isMe = sp.slot === mySlot;
        // Only render: ourselves, or players who are actually connected
        if (!isMe && !sp.connected) continue;
        // Our player: use local prediction. Other players: use interpolated position (fallback to server).
        const ip = (!isMe && interp) ? interp.getPlayer(sp.slot) : null;
        const px = isMe && pred ? pred.x     : (ip ? ip.x     : sp.x);
        const py = isMe && pred ? pred.y     : (ip ? ip.y     : sp.y);
        const pa = isMe && pred ? pred.angle : (ip ? ip.angle : sp.angle);
        const ph = isMe && pred ? pred.hp    : (ip ? ip.hp    : sp.hp);
        const pm = isMe && pred ? pred.maxHp : (ip ? ip.maxHp : sp.maxHp);
        const alive = isMe && pred ? pred.alive : (ip ? ip.alive : sp.alive);
        const hs = 14;

        if (!alive) {
          ctx.globalAlpha = 0.3;
          ctx.fillStyle = sp.color; ctx.fillRect(px-hs, py-hs, hs*2, hs*2);
          ctx.globalAlpha = 1; continue;
        }

        ctx.save(); ctx.translate(px, py); ctx.rotate(pa);
        ctx.fillStyle = sp.color; ctx.shadowColor = sp.color; ctx.shadowBlur = 10;
        ctx.fillRect(-hs, -hs, hs*2, hs*2);
        ctx.fillStyle = '#000'; ctx.fillRect(4, -4, 12, 8);
        ctx.shadowBlur = 0; ctx.restore();

        ctx.fillStyle = '#333'; ctx.fillRect(px-hs, py-hs-10, hs*2, 5);
        ctx.fillStyle = ph > 40 ? '#00ff00' : ph > 20 ? '#ffff00' : '#ff0000';
        ctx.fillRect(px-hs, py-hs-10, (hs*2)*(ph/pm), 5);

        ctx.fillStyle = '#fff'; ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('P'+sp.slot, px, py);

        ctx.fillStyle = sp.color; ctx.font = 'bold 10px Courier New';
        ctx.textBaseline = 'bottom';
        ctx.fillText('$'+sp.points, px, py-hs-12);

        if (isMe) {
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.35;
          ctx.strokeRect(px-hs-4, py-hs-4, (hs+4)*2, (hs+4)*2);
          ctx.globalAlpha = 1;
        }
      }

      // ── Border (always on top) ────────────────────────────────────
      ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 4;
      ctx.shadowColor = '#00ff00'; ctx.shadowBlur = 12;
      ctx.strokeRect(2, 2, W-4, H-4);
      ctx.shadowBlur = 0;

      // ── Wave banner ───────────────────────────────────────────────
      if (this.waveTimer > 0) {
        const alpha = Math.min(1, this.waveTimer/30);
        ctx.save(); ctx.globalAlpha = alpha;
        ctx.font = 'bold 48px Courier New'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillStyle = this.waveText.includes('BOSS') ? '#ff00ff' : '#ff3300';
        ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 30;
        ctx.fillText(this.waveText, W/2, H/2);
        ctx.shadowBlur = 0; ctx.restore();
      }

      ctx.fillStyle = '#333'; ctx.font = '14px Courier New';
      ctx.textAlign = 'right'; ctx.textBaseline = 'top';
      ctx.fillText('WAVE ' + state.wave, W-12, 12);

    }
  }

  // ================================================================
  // REMOTE CLIENT
  // ================================================================
  class RemoteClient {
    constructor() {
      this.socket = io({
        transports: ['websocket'],
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: 500,
        reconnectionDelayMax: 2000,
        timeout: 5000
      });

      this.roomCode    = null;
      this.slot        = null;
      this.color       = null;
      this.firing      = false;
      this.meleeing    = false;
      this.inMeleeMode = false;
      this.isReady     = false;
      this.hasVoted    = false;

      this.pred      = null;   // Prediction engine
      this.renderer  = null;   // Renderer
      this.interp    = null;   // Entity interpolator
      this.lastState = null;   // Latest server snapshot

      this.inputTimer = null;  // 20Hz input send loop
      this.simTimer   = null;  // 60Hz local sim + render loop
      this.pingTimer  = null;
      this.pingStart  = 0;

      this.joystick = new Joystick('joystick-zone', 'joystick-knob');
      this.fp = this.loadFP();

      this.bindSocket();
      this.bindJoinUI();
      this.bindLobbyUI();
      this.bindGameUI();
      this.bindGameoverUI();
      this.checkDeepLink();
    }

    loadFP() {
      let fp = sessionStorage.getItem('zt-fp');
      if (!fp) { fp = 'fp-'+Date.now()+'-'+Math.random().toString(36).slice(2); sessionStorage.setItem('zt-fp', fp); }
      return fp;
    }

    checkDeepLink() {
      const code = new URLSearchParams(window.location.search).get('room');
      if (code && code.length === 4) {
        document.getElementById('room-code-input').value = code.toUpperCase();
        this._pending = code.toUpperCase();
      }
    }

    bindSocket() {
      this.socket.on('connect', () => {
        this.setStatus('OK');
        if (this._pending) { this.joinRoom(this._pending); this._pending = null; }
        else if (this.roomCode) this.socket.emit('join-room', { roomCode: this.roomCode, deviceFingerprint: this.fp });
        this.startPingLoop();
      });

      this.socket.on('disconnect', () => {
        this.setStatus('RECONNECTING...');
        this.stopGame();
      });

      this.socket.on('pong-ack', () => {
        const ms = Date.now() - this.pingStart;
        document.getElementById('ping-display').textContent = ms + ' ms';
      });

      this.socket.on('join-success',  d => this.onJoinSuccess(d));
      this.socket.on('join-failed',   d => this.showError(d.reason));
      this.socket.on('lobby-update',  d => this.updateLobby(d));
      this.socket.on('game-starting-remote', () => this.startGame());

      // Server state arrives ~30Hz — reconcile prediction, update HUD
      this.socket.on('remote-game-state', state => {
        this.lastState = state;

        if (this.pred && state.players) {
          const sp = state.players[this.slot - 1];
          if (sp) {
            // Seed/reconcile using our slot data regardless of connected flag
            // (server may not have marked us connected yet on first tick)
            if (!this.pred.seeded) this.pred.seed(sp);
            else                   this.pred.reconcile(sp);
          }
        }
        // Feed new state to interpolator for other players + zombies
        if (this.interp) this.interp.onServerState(state, this.slot);

        this.updateHUD(state);
        if (state.gameOver) this.showScreen('gameover-screen');
      });

      this.socket.on('wave-event', d => {
        if (this.renderer) this.renderer.showWave(d.type === 'boss' ? 'BOSS WAVE' : 'WAVE ' + d.wave);
      });

      this.socket.on('game-over', () => this.showScreen('gameover-screen'));

      this.socket.on('restart-vote-update', d => {
        document.getElementById('vote-status').textContent = `Votes: ${d.votes} / ${d.needed}`;
      });

      this.socket.on('game-restarting-remote', () => {
        this.isReady = false; this.hasVoted = false;
        this.stopGame();
        this.showScreen('lobby-screen');
        document.getElementById('ready-btn').textContent = 'READY UP';
        document.getElementById('ready-btn').classList.remove('voted');
        document.getElementById('waiting-text').textContent = '';
      });
    }

    startPingLoop() {
      if (this.pingTimer) clearInterval(this.pingTimer);
      this.pingTimer = setInterval(() => {
        this.pingStart = Date.now();
        this.socket.emit('ping-measure');
      }, 2000);
    }

    bindJoinUI() {
      document.getElementById('new-room-btn').addEventListener('click', () => {
        this.socket.emit('create-remote-room');
      });
      document.getElementById('join-btn').addEventListener('click', () => {
        const code = document.getElementById('room-code-input').value.trim().toUpperCase();
        if (code.length !== 4) { this.showError('Enter a 4-character code'); return; }
        this.joinRoom(code);
      });
      const input = document.getElementById('room-code-input');
      input.addEventListener('input',    e => { e.target.value = e.target.value.toUpperCase(); });
      input.addEventListener('keypress', e => { if (e.key==='Enter') document.getElementById('join-btn').click(); });
    }

    joinRoom(code) {
      this.roomCode = code;
      sessionStorage.setItem('zt-room', code);
      this.socket.emit('join-room', { roomCode: code, deviceFingerprint: this.fp });
    }

    onJoinSuccess(data) {
      this.slot = data.slotNumber; this.color = data.color; this.roomCode = data.roomCode;
      sessionStorage.setItem('zt-fp', data.deviceFingerprint);
      document.getElementById('room-code-display').textContent = this.roomCode;
      const badge = document.getElementById('my-badge');
      badge.textContent = 'PLAYER ' + this.slot;
      badge.style.color = this.color; badge.style.borderColor = this.color;
      this.showScreen('lobby-screen');
      this.setStatus('P' + this.slot);
      this.requestWakeLock();
    }

    bindLobbyUI() {
      document.getElementById('share-btn').addEventListener('click', async () => {
        const url = `${window.location.origin}/join/${this.roomCode}`;
        const btn = document.getElementById('share-btn');
        if (navigator.share) {
          try { await navigator.share({ title: 'Z-TEAM', text: `Join! Room: ${this.roomCode}`, url }); } catch(e) {}
        } else {
          try {
            await navigator.clipboard.writeText(url);
            btn.textContent = 'LINK COPIED!'; btn.classList.add('copied');
            setTimeout(() => { btn.textContent = 'SHARE INVITE LINK'; btn.classList.remove('copied'); }, 2000);
          } catch(e) {}
        }
      });

      document.getElementById('ready-btn').addEventListener('click', () => {
        if (this.isReady) return;
        this.isReady = true;
        document.getElementById('ready-btn').textContent = 'READY!';
        document.getElementById('ready-btn').classList.add('voted');
        document.getElementById('waiting-text').textContent = 'Waiting for others...';
        this.socket.emit('player-ready', { roomCode: this.roomCode });
      });
    }

    updateLobby(data) {
      const list = document.getElementById('player-list');
      list.innerHTML = '';
      for (let s = 1; s <= 4; s++) {
        const p = data.players.find(p => p.slotNumber === s);
        const row = document.createElement('div');
        row.className = 'player-row';
        if (p) {
          row.innerHTML = `<span class="pname" style="color:${p.color}">PLAYER ${p.slotNumber}${p.slotNumber===this.slot?' (YOU)':''}</span>
            <span class="pstatus ${p.ready?'ready':''}">${p.ready?'READY':'WAITING'}</span>`;
        } else {
          row.innerHTML = `<span class="pname" style="color:#333">PLAYER ${s}</span><span class="pstatus">OPEN</span>`;
        }
        list.appendChild(row);
      }
    }

    bindGameUI() {
      const fireBtn = document.getElementById('fire-btn');
      const press = e => {
        e.preventDefault();
        if (this.inMeleeMode) this.meleeing = true; else this.firing = true;
        fireBtn.classList.add('active');
      };
      const release = e => {
        e.preventDefault(); this.firing = false; this.meleeing = false; fireBtn.classList.remove('active');
      };
      fireBtn.addEventListener('touchstart',  press,   { passive: false });
      fireBtn.addEventListener('touchend',    release, { passive: false });
      fireBtn.addEventListener('touchcancel', release, { passive: false });
      document.getElementById('mystery-box-btn').addEventListener('click', () => {
        this.socket.emit('mystery-box-purchase', { roomCode: this.roomCode });
      });
    }

    startGame() {
      this.showScreen('game-screen');

      // Init immediately — don't wait for setTimeout.
      // Server starts sending state right away; we must be ready to receive it.
      this.renderer = new Renderer(document.getElementById('game-canvas'));
      this.pred     = new Prediction(this.slot, this.color);
      this.interp   = new Interpolator();

      // If lastState already arrived before we got here, seed now
      if (this.lastState) {
        this.interp.onServerState(this.lastState, this.slot);
        const sp = this.lastState.players?.[this.slot - 1];
        if (sp && !this.pred.seeded) this.pred.seed(sp);
      }

      // 60fps render loop via requestAnimationFrame — far smoother than setInterval on mobile
      const loop = () => {
        this.simTimer = requestAnimationFrame(loop);
        if (!this.lastState) return;
        this.pred.tick(this.joystick.getAngle(), this.firing, this.inMeleeMode);
        this.interp.tick();
        this.renderer.draw(this.lastState, this.pred, this.slot, this.interp);
      };
      this.simTimer = requestAnimationFrame(loop);

      // 20Hz input loop — send to server independently of render
      this.inputTimer = setInterval(() => {
        if (!this.roomCode) return;
        this.socket.emit('player-input', {
          roomCode: this.roomCode,
          input: { angle: this.joystick.getAngle(), fire: this.firing, melee: this.meleeing }
        });
      }, 50);

      // Resize canvas now and again after layout settles
      this.renderer.resize();
      setTimeout(() => this.renderer.resize(), 150);
    }

    stopGame() {
      if (this.simTimer)   { cancelAnimationFrame(this.simTimer); this.simTimer   = null; }
      if (this.inputTimer) { clearInterval(this.inputTimer);      this.inputTimer = null; }
    }

    updateHUD(state) {
      const p = state.players?.[this.slot - 1];
      if (!p) return;

      const ammoEl = document.getElementById('hud-ammo');
      if (p.ammo === -1)    { ammoEl.textContent = '∞';   ammoEl.className = ''; this.setMeleeMode(false); }
      else if (p.ammo === 0){ ammoEl.textContent = 'OUT'; ammoEl.className = 'empty'; this.setMeleeMode(true); }
      else {
        ammoEl.textContent = p.ammo;
        ammoEl.className   = p.ammo <= 5 ? 'low' : '';
        this.setMeleeMode(false);
        if (this.pred) this.pred.fireRate = WEAPON_FIRE_RATES[p.weapon] || 10;
      }

      document.getElementById('hud-weapon').textContent = (p.weapon||'pistol').toUpperCase().replace('_',' ');
      document.getElementById('hud-points').textContent = '$' + p.points;
      document.getElementById('hud-wave').textContent   = 'WAVE ' + state.wave;

      const box = document.getElementById('mystery-box-btn');
      if (p.canUseMysteryBox && p.points >= 950) { box.disabled = false; box.classList.add('pulse'); }
      else                                        { box.disabled = true;  box.classList.remove('pulse'); }
    }

    setMeleeMode(active) {
      if (this.inMeleeMode === active) return;
      this.inMeleeMode = active;
      const btn = document.getElementById('fire-btn');
      if (active) { btn.classList.add('melee-mode'); btn.childNodes[0].textContent = 'KNIFE'; this.firing = false; }
      else        { btn.classList.remove('melee-mode'); btn.childNodes[0].textContent = 'FIRE'; this.meleeing = false; }
    }

    bindGameoverUI() {
      document.getElementById('restart-btn').addEventListener('click', () => {
        if (this.hasVoted) return;
        this.hasVoted = true;
        document.getElementById('restart-btn').textContent = 'VOTED!';
        document.getElementById('restart-btn').classList.add('voted');
        document.getElementById('vote-status').textContent = 'Waiting for others...';
        this.socket.emit('restart-vote-remote', { roomCode: this.roomCode });
      });
    }

    showScreen(id) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(id).classList.add('active');
      if (id === 'game-screen' && this.renderer) setTimeout(() => this.renderer.resize(), 50);
    }

    showError(msg) {
      const el = document.getElementById('join-error');
      el.textContent = msg;
      setTimeout(() => { el.textContent = ''; }, 3000);
    }

    setStatus(msg) { document.getElementById('status-bar').textContent = msg; }

    async requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          await navigator.wakeLock.request('screen');
          document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') try { await navigator.wakeLock.request('screen'); } catch(_){}
          });
        }
      } catch(e) {}
    }
  }

  const client = new RemoteClient();
  document.body.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
  </script>
</body>
</html>
