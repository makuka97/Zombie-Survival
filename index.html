<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zombie Survival - Host</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }

    #game-container {
      position: relative;
      overflow: hidden;
    }

    #canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    #room-code-display {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      padding: 15px 30px;
      border-radius: 10px;
      border: 2px solid #00ff00;
      text-align: center;
      z-index: 100;
      transition: opacity 1.5s ease;
      display: flex;
      align-items: center;
      gap: 30px;
    }
    
    body:has(#lobby-screen[style*="display: block"]) #room-code-display,
    body:has(#lobby-screen[style*="display: flex"]) #room-code-display {
      opacity: 0;
      pointer-events: none;
    }

    #room-code-text { text-align: center; }
    #room-code-display p { color: #00ff00; font-size: 16px; margin-bottom: 5px; }
    #room-code { font-size: 48px; font-weight: bold; letter-spacing: 6px; color: #fff; }
    
    #qr-code {
      background: #fff;
      padding: 10px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #qr-code canvas { display: block; }

    #lobby-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 150;
      width: 90%;
      max-width: 600px;
      padding: 20px;
      margin-top: 60px;
    }

    #lobby-players { display: flex; flex-direction: column; gap: 12px; margin-bottom: 30px; margin-top: 40px; }
    .lobby-slot {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(0,0,0,0.8);
      border: 2px solid #333;
      border-radius: 12px;
      padding: 10px 16px;
      font-size: clamp(14px, 3vw, 22px);
      letter-spacing: 2px;
    }
    .lobby-slot.connected { border-color: #555; }
    .lobby-slot.ready     { border-color: #00ff00; }

    .slot-color {
      width: clamp(20px, 4vw, 28px);
      height: clamp(20px, 4vw, 28px);
      border-radius: 4px;
      margin-right: 10px;
      flex-shrink: 0;
    }
    .slot-name { flex: 1; text-align: left; color: #fff; }
    .slot-status {
      font-size: clamp(12px, 2.5vw, 16px);
      letter-spacing: 2px;
      padding: 4px 10px;
      border-radius: 8px;
    }
    .status-waiting { color: #555; border: 1px solid #333; }
    .status-joined  { color: #aaa; border: 1px solid #555; }
    .status-ready   { color: #00ff00; border: 1px solid #00ff00; background: rgba(0,255,0,0.1); }

    #countdown {
      font-size: clamp(60px, 15vw, 100px);
      font-weight: bold;
      color: #ff0000;
      text-shadow: 0 0 30px #ff0000;
      display: none;
      animation: pop 0.3s ease;
    }
    @keyframes pop { 0% { transform: scale(1.4); } 100% { transform: scale(1); } }

    #game-info {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      border: 2px solid #00ff00;
      color: #fff;
      display: none;
    }
    .info-line { font-size: 18px; margin: 5px 0; }
    .info-line span { color: #00ff00; font-weight: bold; }

    #wave-banner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(40px, 10vw, 72px);
      font-weight: bold;
      color: #ff0000;
      text-shadow: 0 0 20px #ff0000;
      display: none;
      z-index: 200;
    }

    #game-over-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      display: none;
      z-index: 200;
      background: rgba(0,0,0,0.9);
      padding: clamp(20px, 5vw, 40px) clamp(30px, 8vw, 60px);
      border-radius: 20px;
      border: 3px solid #ff0000;
      max-width: 90%;
    }
    #game-over-screen h1 {
      font-size: clamp(40px, 10vw, 80px);
      color: #ff0000;
      text-shadow: 0 0 30px #ff0000;
    }
    #game-over-screen p { font-size: clamp(14px, 3vw, 24px); color: #fff; margin-top: 20px; }
    #vote-display { font-size: clamp(16px, 4vw, 28px); color: #00ff00; margin-top: 20px; }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="canvas" width="1334" height="750"></canvas>

    <div id="room-code-display">
      <div id="room-code-text">
        <p>SCAN TO JOIN</p>
        <div id="room-code">----</div>
      </div>
      <div id="qr-code"></div>
    </div>

    <div id="lobby-screen">
      <div id="lobby-players">
        <div class="lobby-slot" id="slot-1">
          <div class="slot-color" style="background:#00ffff"></div>
          <div class="slot-name">PLAYER 1</div>
          <div class="slot-status status-waiting">EMPTY</div>
        </div>
        <div class="lobby-slot" id="slot-2">
          <div class="slot-color" style="background:#ff44ff"></div>
          <div class="slot-name">PLAYER 2</div>
          <div class="slot-status status-waiting">EMPTY</div>
        </div>
        <div class="lobby-slot" id="slot-3">
          <div class="slot-color" style="background:#4488ff"></div>
          <div class="slot-name">PLAYER 3</div>
          <div class="slot-status status-waiting">EMPTY</div>
        </div>
        <div class="lobby-slot" id="slot-4">
          <div class="slot-color" style="background:#ffff00"></div>
          <div class="slot-name">PLAYER 4</div>
          <div class="slot-status status-waiting">EMPTY</div>
        </div>
      </div>
      <div id="countdown"></div>
    </div>

    <div id="game-info">
      <div class="info-line">WAVE: <span id="wave">1</span></div>
      <div class="info-line">ZOMBIES: <span id="zombie-count">0</span></div>
      <div class="info-line">PLAYERS: <span id="player-count">0</span>/4</div>
    </div>

    <div id="wave-banner"></div>
    <div id="game-over-screen">
      <h1>GAME OVER</h1>
      <p>All players have fallen</p>
      <div id="vote-display">Waiting for restart votes...</div>
    </div>
  </div>

  <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>
  <script src="/shared/game-constants.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ── Pull shared constants (defined in /shared/game-constants.js) ──
    const {
      WEAPONS, ZOMBIE_TYPES,
      MYSTERY_BOX_COST, BOX_USE_RANGE,
      VENDING_BASE_COST, VENDING_COST_STEP, VENDING_HEAL_AMOUNT, VENDING_USE_RANGE,
      JUGGERNOG_COST, JUGGERNOG_HP_BONUS, JUGGERNOG_USE_RANGE,
      PAP_USE_RANGE, PAP_TIERS,
      MELEE_DAMAGE, MELEE_RANGE, MELEE_ARC,
      PLAYER_SPAWNS, BOSS_TYPES, BOSS_CONFIGS,
      BOMBER_BLAST_RADIUS, BOMBER_PLAYER_DAMAGE, BOMBER_CHAIN_DEPTH
    } = GAME_CONSTANTS;

    class GameEngine {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx    = this.canvas.getContext('2d');

        this.PLAYER_SIZE  = 28;
        this.BULLET_SIZE  = 6;
        this.AMMO_SIZE    = 20;
        this.BOX_SIZE     = 50;
        this.PLAYER_SPEED = 3.5;
        this.BULLET_SPEED = 8;
        this.REVIVE_RADIUS = 40;
        this.REVIVE_TIME   = 3000;
        this.AMMO_DROP_CHANCE = 0.3;
        this.WALL_INSET = 6;

        this.players    = [];
        this.zombies    = [];
        this.bullets    = [];
        this.ammoPacks  = [];
        this.healthPacks = [];
        this.wave       = 1;
        this.waveTotal  = 0;
        this.waveKilled = 0;
        this.gameOver   = false;
        this.gameStarted = false;
        this._spawnTimeouts = []; // tracked so stale wave spawns can be cancelled
        this.reviveMap  = new Map();
        this.mysteryBox  = null;
        this.vendingMachine = null;
        this.vendingCost    = VENDING_BASE_COST; // persists all game, resets on restart
        this.juggernogMachine = null;
        this.papMachine       = null;

        this.meleeFlashes = [];

        // ── Particle object pool ────────────────────────────────
        // Pre-allocate all slots once; never push/splice at runtime.
        // Pool sizes: zombie death=15, bomber explosion=20,
        //             pistol=10, smg=10, shotgun=10, ar=10, lmg=10,
        //             raygun=40, thundergun=40  → total = 165
        this.PARTICLE_POOL_SIZE = 165;
        this.particles = Array.from({ length: this.PARTICLE_POOL_SIZE }, () => ({
          x:0, y:0, vx:0, vy:0, color:'#fff', life:0, maxLife:1, size:1
        }));
        // ────────────────────────────────────────────────────────

        this.boss = null;

        this.socket   = null;
        this.roomCode = null;
        this._hudFrame = 0; // throttle DOM HUD updates to every 10 frames

        // ── Pre-bake background grid once — blit each frame instead of 50+ strokes ──
        this._buildGridCache();

        this.initPlayers();
      }

      _buildGridCache() {
        const W = this.canvas.width, H = this.canvas.height;
        this._gridCanvas = document.createElement('canvas');
        this._gridCanvas.width  = W;
        this._gridCanvas.height = H;
        const g = this._gridCanvas.getContext('2d');
        g.fillStyle = '#111';
        g.fillRect(0, 0, W, H);
        g.strokeStyle = 'rgba(0,255,0,0.05)'; g.lineWidth = 1;
        for (let x = 0; x < W; x += 60) { g.beginPath(); g.moveTo(x,0); g.lineTo(x,H); g.stroke(); }
        for (let y = 0; y < H; y += 60) { g.beginPath(); g.moveTo(0,y); g.lineTo(W,y); g.stroke(); }
      }

      initPlayers() {
        const colors = ['#00ffff','#ff44ff','#4488ff','#ffff00'];
        for (let i = 0; i < 4; i++) {
          this.players[i] = {
            slot: i + 1,
            x: PLAYER_SPAWNS[i].x, y: PLAYER_SPAWNS[i].y,
            vx: 0, vy: 0, angle: 0,
            color: colors[i],
            hp: 100, maxHp: 100,
            ammo: 30,
            points: 0,
            currentWeapon: 'pistol',
            hasJuggernog: false,
            papTier: 0,          // 0 = not punched, 1/2/3 = PaP tier
            alive: true, connected: false,
            meleeing: false,
            meleeCooldown: 0,
          };
        }
      }

      addPlayer(slot) {
        const p = this.players[slot-1];
        p.connected = true;
        // If a player joins mid-boss-wave make sure they also have infinite ammo
        if (this.isBossWave) { p.savedAmmo = p.ammo; p.ammo = Infinity; }
        this.updateHUD();
      }
      removePlayer(slot) { this.players[slot-1].connected = false; this.updateHUD(); }
      connectedCount()   { return this.players.filter(p => p.connected).length; }

      updateLobby(players) {
        for (let i = 1; i <= 4; i++) {
          const slot   = document.getElementById(`slot-${i}`);
          const status = slot.querySelector('.slot-status');
          const found  = players.find(p => p.slotNumber === i);
          if (!found) {
            slot.className = 'lobby-slot'; status.className = 'slot-status status-waiting'; status.textContent = 'EMPTY';
          } else if (found.ready) {
            slot.className = 'lobby-slot ready'; status.className = 'slot-status status-ready'; status.textContent = 'READY!';
          } else {
            slot.className = 'lobby-slot connected'; status.className = 'slot-status status-joined'; status.textContent = 'JOINED';
          }
        }
      }

      startCountdown() {
        const countdown = document.getElementById('countdown');
        countdown.style.display = 'block';
        let count = 3;
        countdown.textContent = count;
        const tick = setInterval(() => {
          count--;
          if (count > 0) {
            countdown.style.animation = 'none';
            countdown.offsetHeight;
            countdown.style.animation = 'pop 0.3s ease';
            countdown.textContent = count;
          } else {
            clearInterval(tick);
            this.beginGame();
          }
        }, 1000);
      }

      beginGame() {
        this.gameStarted = true;
        document.getElementById('lobby-screen').style.display = 'none';
        document.getElementById('game-info').style.display    = 'block';
        const codeDisplay = document.getElementById('room-code-display');
        codeDisplay.style.opacity = '0';
        setTimeout(() => { codeDisplay.style.display = 'none'; }, 1500);
        this.spawnMysteryBox();
        this.spawnVendingMachine();
        this.spawnPerkMachines();
        setTimeout(() => this.startWave(), 500);
      }

      handleInput(slot, input) {
        const p = this.players[slot - 1];
        if (!p || !p.alive) return;
        if (input.angle !== null && input.angle !== undefined) {
          p.vx    = Math.cos(input.angle) * this.PLAYER_SPEED;
          p.vy    = Math.sin(input.angle) * this.PLAYER_SPEED;
          p.angle = input.angle;
        } else {
          p.vx = 0; p.vy = 0;
        }
        p.firing   = !!input.fire;
        p.meleeing = !!input.melee;
      }

      handleMysteryBoxPurchase(slot) {
        const p = this.players[slot - 1];
        if (!p || !p.alive || !this.mysteryBox) return;
        const dx = p.x - this.mysteryBox.x, dy = p.y - this.mysteryBox.y;
        if (Math.sqrt(dx*dx+dy*dy) > BOX_USE_RANGE) return;
        if (p.points < MYSTERY_BOX_COST) return;
        p.points -= MYSTERY_BOX_COST;
        const weapon = this.rollRandomWeapon();
        p.currentWeapon = weapon;
        if (this.isBossWave) {
          // During boss wave: stay on Infinity, update savedAmmo to new weapon's capacity
          // so the correct ammo is restored when the boss wave ends
          p.ammo = Infinity;
          p.savedAmmo = WEAPONS[weapon].ammoCapacity;
        } else {
          p.ammo = this.getEffectiveAmmoCapacity(p);
        }
        setTimeout(() => this.spawnMysteryBox(), 1000);
      }

      rollRandomWeapon() {
        const roll = Math.random() * 100;
        if (roll < 10) {
          const l = Object.keys(WEAPONS).filter(k => WEAPONS[k].rarity === 'legendary');
          return l[Math.floor(Math.random() * l.length)];
        } else if (roll < 40) {
          const r = Object.keys(WEAPONS).filter(k => WEAPONS[k].rarity === 'rare');
          return r[Math.floor(Math.random() * r.length)];
        } else {
          const c = Object.keys(WEAPONS).filter(k => WEAPONS[k].rarity === 'common');
          return c[Math.floor(Math.random() * c.length)];
        }
      }

      // ── KILL TIER SYSTEM ────────────────────────────────────────────
      // Called every time a player gets a zombie kill.
      // Checks if they've crossed a tier threshold — if so, upgrades
      // Returns damage for a player — PaP multiplier only
      getEffectiveDamage(player, baseDamage) {
        const papMult = player.papTier > 0 ? PAP_TIERS[player.papTier - 1].damageMult : 1;
        return Math.ceil(baseDamage * papMult);
      }

      // Returns ammo capacity — PaP multiplier only
      getEffectiveAmmoCapacity(player) {
        const base    = WEAPONS[player.currentWeapon].ammoCapacity;
        const papMult = player.papTier > 0 ? PAP_TIERS[player.papTier - 1].ammoMult : 1;
        return Math.floor(base * papMult);
      }

      spawnMysteryBox() {
        const margin = 100;
        this.mysteryBox = {
          x: margin + Math.random() * (this.canvas.width  - margin * 2),
          y: margin + Math.random() * (this.canvas.height - margin * 2)
        };
      }

      spawnVendingMachine() {
        if (this.isBossWave) { this.vendingMachine = null; return; }
        const margin = 160;
        let x, y, attempts = 0;
        do {
          x = margin + Math.random() * (this.canvas.width  - margin * 2);
          y = margin + Math.random() * (this.canvas.height - margin * 2);
          attempts++;
          if (this.mysteryBox) {
            const dx = x - this.mysteryBox.x, dy = y - this.mysteryBox.y;
            if (Math.sqrt(dx*dx+dy*dy) < 200 && attempts < 20) continue;
          }
          break;
        } while (true);
        this.vendingMachine = { x, y };
      }

      // Spawn Juggernog and PaP at random non-overlapping positions
      _randomMachinePos(others = []) {
        const margin = 160, W = this.canvas.width, H = this.canvas.height;
        for (let attempt = 0; attempt < 30; attempt++) {
          const x = margin + Math.random() * (W - margin * 2);
          const y = margin + Math.random() * (H - margin * 2);
          let ok = true;
          for (const o of others) {
            if (!o) continue;
            const dx = x - o.x, dy = y - o.y;
            if (Math.sqrt(dx*dx+dy*dy) < 220) { ok = false; break; }
          }
          if (ok) return { x, y };
        }
        // fallback
        return { x: margin + Math.random() * (W - margin * 2), y: margin + Math.random() * (H - margin * 2) };
      }

      spawnPerkMachines() {
        const others = [this.mysteryBox, this.vendingMachine];
        this.juggernogMachine = this._randomMachinePos(others);
        others.push(this.juggernogMachine);
        this.papMachine = this._randomMachinePos(others);
      }

      handleJuggernogPurchase(slot) {
        const p = this.players[slot - 1];
        if (!p || !p.alive || !this.juggernogMachine) return;
        if (p.hasJuggernog) return; // already bought
        const dx = p.x - this.juggernogMachine.x, dy = p.y - this.juggernogMachine.y;
        if (Math.sqrt(dx*dx+dy*dy) > JUGGERNOG_USE_RANGE) return;
        if (p.points < JUGGERNOG_COST) return;
        p.points -= JUGGERNOG_COST;
        p.hasJuggernog = true;
        p.maxHp += JUGGERNOG_HP_BONUS;
        p.hp    += JUGGERNOG_HP_BONUS; // also heal for the bonus amount
      }

      handlePapPurchase(slot) {
        const p = this.players[slot - 1];
        if (!p || !p.alive || !this.papMachine) return;
        if (p.papTier >= PAP_TIERS.length) return; // already max tier
        const dx = p.x - this.papMachine.x, dy = p.y - this.papMachine.y;
        if (Math.sqrt(dx*dx+dy*dy) > PAP_USE_RANGE) return;
        const nextTier = PAP_TIERS[p.papTier]; // 0-indexed into PAP_TIERS
        if (p.points < nextTier.cost) return;
        p.points  -= nextTier.cost;
        p.papTier += 1;
        // Refill ammo with new capacity
        p.ammo = this.isBossWave ? Infinity : this.getEffectiveAmmoCapacity(p);
        if (this.isBossWave) p.savedAmmo = this.getEffectiveAmmoCapacity(p);
      }

      canUseJuggernog(player) {
        if (!this.juggernogMachine || !player.alive || player.hasJuggernog) return false;
        const dx = player.x - this.juggernogMachine.x, dy = player.y - this.juggernogMachine.y;
        return Math.sqrt(dx*dx+dy*dy) <= JUGGERNOG_USE_RANGE;
      }

      canUsePap(player) {
        if (!this.papMachine || !player.alive || player.papTier >= PAP_TIERS.length) return false;
        const dx = player.x - this.papMachine.x, dy = player.y - this.papMachine.y;
        return Math.sqrt(dx*dx+dy*dy) <= PAP_USE_RANGE;
      }

      handleVendingPurchase(slot) {
        const p = this.players[slot - 1];
        if (!p || !p.alive || !this.vendingMachine) return;
        const dx = p.x - this.vendingMachine.x, dy = p.y - this.vendingMachine.y;
        if (Math.sqrt(dx*dx+dy*dy) > VENDING_USE_RANGE) return;
        if (p.points < this.vendingCost) return;
        if (p.hp >= p.maxHp) return;
        p.points       -= this.vendingCost;
        p.hp            = Math.min(p.maxHp, p.hp + VENDING_HEAL_AMOUNT);
        this.vendingCost += VENDING_COST_STEP;
      }

      startWave() {
        // Cancel any zombie spawns still pending from the previous wave
        for (const t of this._spawnTimeouts) clearTimeout(t);
        this._spawnTimeouts = [];

        const playerCount = Math.max(1, this.connectedCount());
        this.waveKilled = 0;

        if (this.wave % 5 === 0) {
          this.isBossWave = true;
          this.waveTotal = 1;
          this.showBanner('BOSS FIGHT');
          for (let p of this.players) {
            if (!p.connected) continue;
            p.savedAmmo = p.ammo;
            p.ammo = Infinity;
          }
          setTimeout(() => this.spawnBoss(), 2000);
        } else {
          this.isBossWave = false;
          for (let p of this.players) {
            if (!p.connected) continue;
            if (p.savedAmmo !== undefined) {
              const weapon = WEAPONS[p.currentWeapon];
              p.ammo = Math.max(p.savedAmmo, Math.floor(weapon.ammoCapacity * 0.5));
              p.savedAmmo = undefined;
            }
          }
          this.spawnVendingMachine(); // new random location each wave
          // Fewer zombies but they scale in HP — quality over quantity
          const baseCount = 2 + Math.floor((this.wave - 1) * 1.2);
          this.waveTotal  = Math.ceil(baseCount * Math.max(1, playerCount * 0.6));
          this.showBanner('WAVE ' + this.wave);
          for (let i = 0; i < this.waveTotal; i++) {
            this._spawnTimeouts.push(setTimeout(() => this.spawnZombie(), i * 500));
          }
        }
      }

      // ── BOSS FACTORY ─────────────────────────────────────────────────
      getBossType() {
        // Waves 5–30: fixed sequence. Wave 35+: random from all 6 types.
        if (this.wave > 30) {
          return BOSS_TYPES[Math.floor(Math.random() * BOSS_TYPES.length)];
        }
        return BOSS_TYPES[Math.floor((this.wave / 5 - 1)) % BOSS_TYPES.length];
      }

      // Returns a random vivid color for post-wave-30 remix bosses
      _randomBossColor() {
        const colors = [
          '#ff2244', '#ff6600', '#ffcc00', '#00ff88',
          '#00ccff', '#aa44ff', '#ff44cc', '#ffffff',
          '#ff0000', '#00ffff', '#88ff00', '#ff8800',
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      spawnBoss() {
        const W = this.canvas.width, H = this.canvas.height;
        const type    = this.getBossType();
        const cfg     = BOSS_CONFIGS[type];
        const isRemix = this.wave > 30;

        // Post-wave-30 remixes get a random color and a speed bump
        const bossColor = isRemix ? this._randomBossColor() : cfg.color;
        const speedMult = isRemix ? 1.0 + (Math.floor((this.wave - 30) / 5)) * 0.15 : 1.0;

        const base = {
          type,
          x: W / 2, y: -120,
          dropping: true, dropTarget: H / 2,
          vx: (type === 'pentagon' ? 5.5 : 3.5) * speedMult,
          vy: (type === 'pentagon' ? 4.0 : 2.5) * speedMult,
          rotation: 0, spinSpeed: 0.03 * speedMult,
          flashTimer: 0, dead: false,
          bossBullets: [],
          shootTimer: 0,
          radius: cfg.radius, color: bossColor, pad: cfg.pad, label: cfg.label
        };

        if (type === 'triangle') {
          this.boss = { ...base,
            tips: Array.from({length: cfg.tips.count}, () => ({hp: cfg.tips.hp, maxHp: cfg.tips.hp}))
          };
        } else if (type === 'octagon') {
          this.boss = { ...base,
            corners: Array.from({length: cfg.corners.count}, () => ({hp: cfg.corners.hp, maxHp: cfg.corners.hp})),
            shootInterval: cfg.shootInterval
          };
        } else if (type === 'pentagon') {
          this.boss = { ...base,
            panels: Array.from({length: cfg.panels.count}, (_, i) => ({
              hp: cfg.panels.hp, maxHp: cfg.panels.hp,
              state: 'orbit',
              orbitIdx: i,
            })),
            coreHp: 35, coreMaxHp: 35,
            rage: false,
            throwTimer: 60,
            activePanel: -1,              // which panel is currently flying
            boomerang: null,              // { x, y, angle, t, speed, arc } live projectile
            rageShootTimer: 0,
          };
        } else if (type === 'diamond') {
          this.boss = { ...base,
            coreHp: cfg.coreHp, coreMaxHp: cfg.coreHp,
            split: false, shards: []
          };
        } else if (type === 'spiral') {
          this.boss = { ...base,
            arms: Array.from({length: cfg.arms.count}, () => ({hp: cfg.arms.hp, maxHp: cfg.arms.hp})),
            breathe: 0,
            shootTimer: 0,
            summonPhase: 'cooldown',
            summonTimer: 300,
            summonKillTimer: 0,
            summonZombieIds: [],
            consumeFlash: 0,
            consumingZombies: [],   // [{x,y,color,borderColor,size,t,fromX,fromY}] — suck-in animation
          };
        } else { // fractal
          this.boss = { ...base,
            stage: 0,
            pieces: [{x: W/2, y: -120, rotation:0, vx:3.5, vy:2.5, hp:cfg.pieceHp, maxHp:cfg.pieceHp, radius:cfg.radius, alive:true}]
          };
        }
      }

      getBossHitPoints() {
        if (!this.boss) return [];
        const b = this.boss;

        if (b.type === 'triangle') {
          const angles = [
            b.rotation - Math.PI/2,
            b.rotation - Math.PI/2 + (2*Math.PI/3),
            b.rotation - Math.PI/2 + (4*Math.PI/3),
          ];
          return angles.map((a,i) => ({
            x: b.x + Math.cos(a)*b.radius, y: b.y + Math.sin(a)*b.radius, idx: i
          }));
        }
        if (b.type === 'octagon') {
          return b.corners.map((c,i) => {
            const a = b.rotation + (i/8)*Math.PI*2;
            return { x: b.x+Math.cos(a)*b.radius, y: b.y+Math.sin(a)*b.radius, idx: i };
          });
        }
        if (b.type === 'pentagon') {
          const pts = [];
          // Flying boomerang panel is the only hittable target (until rage)
          if (b.boomerang && b.activePanel >= 0) {
            pts.push({ x: b.boomerang.x, y: b.boomerang.y, idx: b.activePanel, boomerang: true });
          }
          // In rage phase the core is exposed
          if (b.rage) {
            pts.push({ x: b.x, y: b.y, idx: -1, core: true });
          }
          return pts;
        }
        if (b.type === 'diamond') {
          if (!b.split) return [{ x: b.x, y: b.y, idx: 0, core: true }];
          // FIX: use real array index so dead shards don't shift the idx of remaining ones
          return b.shards.reduce((acc, s, realIdx) => {
            if (s.alive) acc.push({x:s.x, y:s.y, idx:realIdx, shard:true});
            return acc;
          }, []);
        }
        if (b.type === 'spiral') {
          return b.arms.map((arm,i) => {
            const ext = b.radius + 60 + Math.sin(b.breathe + i) * 30;
            const a   = b.rotation + (i/5)*Math.PI*2;
            return { x: b.x+Math.cos(a)*ext, y: b.y+Math.sin(a)*ext, idx: i };
          });
        }
        if (b.type === 'fractal') {
          // FIX: same real array index fix for fractal pieces
          return b.pieces.reduce((acc, p, realIdx) => {
            if (p.alive) acc.push({x:p.x, y:p.y, idx:realIdx, piece:true, radius:p.radius});
            return acc;
          }, []);
        }
        return [];
      }

      getBossTipPositions() { return this.getBossHitPoints(); }

      // ── Shared boss hit point damage helper (eliminates repeated switch) ──
      _damageBossHitPoint(pt, amount) {
        const b = this.boss; if (!b) return;
        b.flashTimer = 6;
        if      (b.type==='triangle')  b.tips[pt.idx].hp    = Math.max(0, b.tips[pt.idx].hp    - amount);
        else if (b.type==='octagon')   b.corners[pt.idx].hp  = Math.max(0, b.corners[pt.idx].hp  - amount);
        else if (b.type==='pentagon')  {
          if (pt.boomerang && b.activePanel >= 0) {
            // Destroy the flying panel
            b.panels[b.activePanel].hp = 0;
            b.panels[b.activePanel].state = 'dead';
            b.boomerang = null;
            b.activePanel = -1;
            b.throwTimer = Math.max(30, 90 - b.panels.filter(p=>p.state==='dead').length * 15);
          } else if (pt.core && b.rage) {
            b.coreHp = Math.max(0, b.coreHp - amount);
          }
        }
        else if (b.type==='diamond')   {
          if (!b.split) b.coreHp = Math.max(0, b.coreHp - amount);
          else { const s=b.shards[pt.idx]; if(s){s.hp=Math.max(0,s.hp-amount);if(s.hp<=0)s.alive=false;} }
        }
        else if (b.type==='spiral')    b.arms[pt.idx].hp     = Math.max(0, b.arms[pt.idx].hp     - amount);
        else if (b.type==='fractal')   { const alive=b.pieces.filter(p=>p.alive); if(alive[pt.idx])alive[pt.idx].hp=Math.max(0,alive[pt.idx].hp-amount); }
      }

      updateBoss() {
        if (!this.boss) return;
        const b = this.boss;
        const W = this.canvas.width, H = this.canvas.height;
        const WALL = 6;

        if (b.dropping) {
          b.y += 6; b.rotation += b.spinSpeed;
          if (b.y >= b.dropTarget) { b.y = b.dropTarget; b.dropping = false; }
          return;
        }

        if (b.flashTimer > 0) b.flashTimer--;

        for (let i = b.bossBullets.length-1; i >= 0; i--) {
          const bb = b.bossBullets[i];
          bb.x += bb.vx; bb.y += bb.vy; bb.life--;
          if (bb.life <= 0 || bb.x<0||bb.x>W||bb.y<0||bb.y>H) { b.bossBullets.splice(i,1); continue; }
          for (let p of this.players) {
            if (!p.alive||!p.connected) continue;
            const dx=p.x-bb.x, dy=p.y-bb.y;
            if (Math.sqrt(dx*dx+dy*dy) < this.PLAYER_SIZE/2+5) {
              p.hp -= bb.damage; b.bossBullets.splice(i,1);
              if (p.hp<=0&&p.alive){p.alive=false;p.hp=0;this.checkGameOver();}
              break;
            }
          }
        }

        if (b.type === 'triangle')      this._updateTriangleBoss(b, W, H, WALL);
        else if (b.type === 'octagon')  this._updateOctagonBoss(b, W, H, WALL);
        else if (b.type === 'pentagon') this._updatePentagonBoss(b, W, H, WALL);
        else if (b.type === 'diamond')  this._updateDiamondBoss(b, W, H, WALL);
        else if (b.type === 'spiral')   this._updateSpiralBoss(b, W, H, WALL);
        else if (b.type === 'fractal')  this._updateFractalBoss(b, W, H, WALL);
      }

      _bounceBox(b, W, H, WALL) {
        const pad = b.pad;
        b.x += b.vx; b.y += b.vy;
        if (b.x-pad<WALL)     {b.x=WALL+pad;     b.vx= Math.abs(b.vx);}
        if (b.x+pad>W-WALL)   {b.x=W-WALL-pad;   b.vx=-Math.abs(b.vx);}
        if (b.y-pad<WALL)     {b.y=WALL+pad;      b.vy= Math.abs(b.vy);}
        if (b.y+pad>H-WALL)   {b.y=H-WALL-pad;    b.vy=-Math.abs(b.vy);}
      }

      _bossKill(b) {
        b.dead = true;
        const bx = b.x, by = b.y; // capture position before boss is nulled
        for (let p of this.players) {
          if (p.alive && p.connected) { p.points += 1000; p.hp = p.maxHp; }
        }
        setTimeout(() => {
          this.boss = null; this.waveKilled = this.waveTotal; this.wave++;
          this._spawnBossDrops(bx, by); // drops appear immediately when boss dies
          setTimeout(() => this.startWave(), 3000);
        }, 500);
      }

      _spawnBossDrops(bx, by) {
        const W = this.canvas.width, H = this.canvas.height, pad = 40;
        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
        const ammoCount  = 4 + Math.floor(Math.random() * 4); // 4–7 ammo packs
        const healCount  = 2 + Math.floor(Math.random() * 3); // 2–4 health packs
        for (let i = 0; i < ammoCount; i++) {
          const a = Math.random() * Math.PI * 2, d = 40 + Math.random() * 100;
          this.ammoPacks.push({
            x: clamp(bx + Math.cos(a) * d, pad, W - pad),
            y: clamp(by + Math.sin(a) * d, pad, H - pad)
          });
        }
        for (let i = 0; i < healCount; i++) {
          const a = Math.random() * Math.PI * 2, d = 40 + Math.random() * 100;
          this.healthPacks.push({
            x: clamp(bx + Math.cos(a) * d, pad, W - pad),
            y: clamp(by + Math.sin(a) * d, pad, H - pad)
          });
        }
      }

      _bossTouchDamage(b, extraRadius=0) {
        const hs = this.PLAYER_SIZE/2;
        for (let p of this.players) {
          if (!p.alive||!p.connected) continue;
          const dx=p.x-b.x, dy=p.y-b.y;
          if (Math.sqrt(dx*dx+dy*dy) < b.radius+extraRadius+hs) {
            p.hp-=1;
            if (p.hp<=0&&p.alive){p.alive=false;p.hp=0;this.checkGameOver();}
          }
        }
      }

      _updateTriangleBoss(b, W, H, WALL) {
        const tipsAlive = b.tips.filter(t=>t.hp>0).length;
        b.spinSpeed = 0.03 + (3-tipsAlive)*0.025;
        b.rotation += b.spinSpeed;
        this._bounceBox(b,W,H,WALL);
        this._bossTouchDamage(b);
        if (b.tips.every(t=>t.hp<=0)&&!b.dead) this._bossKill(b);
      }

      _updateOctagonBoss(b, W, H, WALL) {
        const alive = b.corners.filter(c=>c.hp>0).length;
        b.spinSpeed = 0.02 + (8-alive)*0.008;
        b.rotation += b.spinSpeed;
        this._bounceBox(b,W,H,WALL);
        this._bossTouchDamage(b);
        b.shootTimer++;
        if (b.shootTimer >= b.shootInterval) {
          b.shootTimer = 0;
          b.corners.forEach((c,i) => {
            if (c.hp<=0) return;
            const a  = b.rotation + (i/8)*Math.PI*2;
            const cx = b.x+Math.cos(a)*b.radius;
            const cy = b.y+Math.sin(a)*b.radius;
            b.bossBullets.push({x:cx,y:cy,vx:Math.cos(a)*3,vy:Math.sin(a)*3,damage:8,life:120,color:'#ff6600'});
          });
        }
        if (b.corners.every(c=>c.hp<=0)&&!b.dead) this._bossKill(b);
      }

      _updatePentagonBoss(b, W, H, WALL) {
        const deadCount  = b.panels.filter(p => p.state === 'dead').length;
        const aliveCount = 5 - deadCount;

        this._bounceBox(b, W, H, WALL);
        b.rotation += 0.015 + deadCount * 0.01; // spins faster as panels die

        // ── RAGE PHASE ──────────────────────────────────────────
        if (b.rage) {
          this._bossTouchDamage(b);
          b.rageShootTimer++;
          if (b.rageShootTimer >= 20) {
            b.rageShootTimer = 0;
            for (let i = 0; i < 2; i++) {
              const a = b.rotation + (i / 2) * Math.PI * 2;
              b.bossBullets.push({ x:b.x, y:b.y, vx:Math.cos(a)*4, vy:Math.sin(a)*4, damage:12, life:110, color:'#0099ff' });
            }
          }
          if (b.coreHp <= 0 && !b.dead) this._bossKill(b);
          return;
        }

        // ── CHECK RAGE TRANSITION ────────────────────────────────
        if (aliveCount === 0 && !b.rage) {
          b.rage = true;
          b.boomerang = null;
          b.activePanel = -1;
          return;
        }

        // ── BOOMERANG THROW ──────────────────────────────────────
        if (b.boomerang) {
          const bm = b.boomerang;
          bm.t += bm.speed;

          // Parametric boomerang arc: ellipse weighted toward and away from center
          const angle = bm.launchAngle + bm.t * Math.PI * 2;
          const dist  = bm.maxDist * Math.sin(bm.t * Math.PI); // rises then falls back
          bm.x = b.x + Math.cos(angle) * dist;
          bm.y = b.y + Math.sin(angle) * dist;

          // Damage players on contact
          for (let p of this.players) {
            if (!p.alive || !p.connected) continue;
            const dx = p.x - bm.x, dy = p.y - bm.y;
            if (Math.sqrt(dx*dx+dy*dy) < 22 + this.PLAYER_SIZE/2) {
              p.hp -= 1.2;
              if (p.hp <= 0 && p.alive) { p.alive = false; p.hp = 0; this.checkGameOver(); }
            }
          }

          // Boomerang completed its arc — returns and reattaches
          if (bm.t >= 1) {
            b.panels[b.activePanel].state = 'orbit';
            b.boomerang = null;
            b.activePanel = -1;
            b.throwTimer = Math.max(15, 55 - deadCount * 10);
          }

        } else {
          // Countdown to next throw
          b.throwTimer--;
          if (b.throwTimer <= 0) {
            // Pick a random alive panel to throw
            const alive = b.panels.map((p,i) => ({p,i})).filter(({p}) => p.state === 'orbit');
            if (alive.length > 0) {
              const pick = alive[Math.floor(Math.random() * alive.length)];
              b.activePanel = pick.i;
              b.panels[pick.i].state = 'flying';
              // Arc tightens as panels die: speed up and vary arc angle
              const speed     = 0.018 + deadCount * 0.006;
              const launchA   = b.rotation + (pick.i / 5) * Math.PI * 2;
              const maxDist   = 200 - deadCount * 15; // tighter arc with fewer panels
              b.boomerang = { x: b.x, y: b.y, t: 0, speed, launchAngle: launchA, maxDist };
            }
          }
        }
      }

      _updateDiamondBoss(b, W, H, WALL) {
        b.rotation += 0.025;
        if (!b.split) {
          this._bounceBox(b,W,H,WALL);
          this._bossTouchDamage(b);
          if (b.coreHp<=0&&!b.dead) {
            b.split = true;
            const cfg  = BOSS_CONFIGS.diamond;
            const dirs = [0,Math.PI/2,Math.PI,Math.PI*1.5];
            b.shards = dirs.map(a => ({
              x:b.x+Math.cos(a)*40, y:b.y+Math.sin(a)*40,
              vx:Math.cos(a)*2.5,   vy:Math.sin(a)*2.5,
              rotation:0, hp:cfg.shardHp, maxHp:cfg.shardHp,
              alive:true, radius:cfg.shardRadius, pad:cfg.shardPad
            }));
          }
        } else {
          for (let s of b.shards) {
            if (!s.alive) continue;
            s.rotation += 0.04;
            s.x+=s.vx; s.y+=s.vy;
            const W2=6;
            if (s.x-s.pad<W2)     {s.x=W2+s.pad;     s.vx= Math.abs(s.vx);}
            if (s.x+s.pad>W-W2)   {s.x=W-W2-s.pad;   s.vx=-Math.abs(s.vx);}
            if (s.y-s.pad<W2)     {s.y=W2+s.pad;      s.vy= Math.abs(s.vy);}
            if (s.y+s.pad>H-W2)   {s.y=H-W2-s.pad;    s.vy=-Math.abs(s.vy);}
            for (let p of this.players) {
              if (!p.alive||!p.connected) continue;
              const dx=p.x-s.x,dy=p.y-s.y;
              if (Math.sqrt(dx*dx+dy*dy)<s.radius+this.PLAYER_SIZE/2){
                p.hp-=0.8;
                if (p.hp<=0&&p.alive){p.alive=false;p.hp=0;this.checkGameOver();}
              }
            }
          }
          b.x = b.shards.reduce((s,sh)=>s+sh.x,0)/4;
          b.y = b.shards.reduce((s,sh)=>s+sh.y,0)/4;
          if (b.shards.every(s=>!s.alive)&&!b.dead) this._bossKill(b);
        }
      }

      _updateSpiralBoss(b, W, H, WALL) {
        b.breathe   += 0.05;
        b.rotation  += 0.02;
        this._bounceBox(b, W, H, WALL);
        this._bossTouchDamage(b, 10);

        if (b.consumeFlash > 0) b.consumeFlash--;

        // ── Shoot from alive arm tips ──────────────────────────────
        b.shootTimer++;
        if (b.shootTimer >= 40) {
          b.shootTimer = 0;
          for (let i = 0; i < 5; i++) {
            if (b.arms[i].hp <= 0) continue; // dead arms don't shoot
            const a = b.rotation + (i / 5) * Math.PI * 2;
            b.bossBullets.push({x:b.x, y:b.y, vx:Math.cos(a)*3.5, vy:Math.sin(a)*3.5, damage:10, life:100, color:'#44ffaa'});
          }
        }

        // ── Summon mechanic ────────────────────────────────────────
        if (b.summonPhase === 'cooldown') {
          b.summonTimer--;
          if (b.summonTimer <= 0) {
            // Spawn 4 yellow adds from edges
            b.summonPhase     = 'summoning';
            b.summonKillTimer = 20 * 60; // 20 seconds at 60fps
            b.summonZombieIds = [];
            this.showBanner('SPIRAL SUMMONS!', '#ffff00');
            for (let i = 0; i < 4; i++) {
              const side = Math.floor(Math.random() * 4);
              let sx, sy;
              if      (side===0){sx=Math.random()*W; sy=-50;}
              else if (side===1){sx=W+50; sy=Math.random()*H;}
              else if (side===2){sx=Math.random()*W; sy=H+50;}
              else              {sx=-50; sy=Math.random()*H;}
              const id = `spiral_add_${Date.now()}_${i}`;
              this.zombies.push({
                x:sx, y:sy, type:'regular',
                hp:3, maxHp:3, speed:1.2, size:28,
                color:'#cccc00', borderColor:'#ffff00',
                points:40, spiralAdd:true, spiralId:id
              });
              b.summonZombieIds.push(id);
            }
          }

        } else if (b.summonPhase === 'summoning') {
          b.summonKillTimer--;
          // Check which adds are still alive
          const aliveAdds = this.zombies.filter(z => z.spiralAdd && b.summonZombieIds.includes(z.spiralId));

          if (aliveAdds.length === 0) {
            // All killed in time — cooldown before next wave
            b.summonPhase = 'cooldown';
            b.summonTimer = 10 * 60;
            this.showBanner('ADDS CLEARED!', '#00ff66');
          } else if (b.summonKillTimer <= 0) {
            // Time's up — begin suck-in animation for survivors
            b.summonPhase = 'consuming';
            b.consumeFlash = 60;

            // Kick off suck-in for each surviving add
            for (const z of aliveAdds) {
              b.consumingZombies.push({
                x: z.x, y: z.y,
                fromX: z.x, fromY: z.y,
                color: z.color, borderColor: z.borderColor, size: z.size,
                t: 0,            // 0→1 over 40 ticks
                spiralId: z.spiralId,
              });
            }
            // Remove them from the live zombie array immediately (they're "captured")
            this.zombies = this.zombies.filter(z => !(z.spiralAdd && b.summonZombieIds.includes(z.spiralId)));

            // Store what to do on arrival — resolve when all animations finish
            b._consumePending = {
              count: aliveAdds.length,
              arrived: 0,
              deadArms: b.arms.reduce((acc, arm, i) => { if (arm.hp <= 0) acc.push(i); return acc; }, []),
            };
            b.summonTimer = 10 * 60;
            b.summonPhase = 'cooldown';
          }
        }

        // ── CONSUMING ZOMBIES — suck-in animation ─────────────────
        if (b.consumingZombies && b.consumingZombies.length > 0) {
          for (let i = b.consumingZombies.length - 1; i >= 0; i--) {
            const cz = b.consumingZombies[i];
            cz.t += 0.035; // ~28 ticks to arrive
            // Ease-in: accelerate toward center
            const ease = cz.t * cz.t;
            cz.x = cz.fromX + (b.x - cz.fromX) * ease;
            cz.y = cz.fromY + (b.y - cz.fromY) * ease;
            // Emit death particles — sparse, 1 per 3 ticks to keep pool pressure low
            if (Math.floor(cz.t * 28) % 3 === 0) {
              this._emitParticle(cz.x, cz.y,
                (Math.random()-0.5)*3, (Math.random()-0.5)*3,
                Math.random() < 0.5 ? cz.borderColor : '#ff4400',
                10, 2 + Math.random()*3);
            }
            if (cz.t >= 1) {
              // Arrived — burst of eaten particles at boss center
              for (let p = 0; p < 8; p++) {
                const a = Math.random() * Math.PI * 2;
                const s = 2 + Math.random() * 4;
                this._emitParticle(b.x, b.y, Math.cos(a)*s, Math.sin(a)*s,
                  p < 4 ? cz.borderColor : '#ff0000', 18, 3 + Math.random()*3);
              }
              b.consumingZombies.splice(i, 1);
              // Resolve regrow for this arrived zombie
              if (b._consumePending) {
                b._consumePending.arrived++;
                const pd = b._consumePending;
                const armIdx = pd.deadArms[pd.arrived - 1];
                if (armIdx !== undefined) {
                  const cfg = BOSS_CONFIGS.spiral;
                  b.arms[armIdx].hp    = Math.ceil(cfg.arms.hp * 0.5);
                  b.arms[armIdx].maxHp = cfg.arms.hp;
                  b.arms[armIdx].regrowing = 30; // flash timer for red glow
                  const n = pd.arrived;
                  this.showBanner(`BOSS REGREW ARM!`, '#ff4444');
                } else if (pd.arrived === 1) {
                  // All arms intact — spew energy once first zombie arrives
                  for (let pl of this.players) {
                    if (!pl.alive || !pl.connected) continue;
                    const dx = pl.x - b.x, dy = pl.y - b.y;
                    for (let s = 0; s < 8; s++) {
                      const spread = (Math.random()-0.5)*0.8;
                      const a = Math.atan2(dy,dx)+spread;
                      b.bossBullets.push({x:b.x,y:b.y,vx:Math.cos(a)*5,vy:Math.sin(a)*5,damage:15,life:120,color:'#00ff44'});
                    }
                  }
                  this.showBanner('BOSS SPEWS ENERGY!', '#ff4444');
                }
                if (pd.arrived >= pd.count) b._consumePending = null;
              }
            }
          }
        }

        // Core is always vulnerable — but killing all arms wins
        if (b.arms.every(a => a.hp <= 0) && !b.dead) this._bossKill(b);
      }

      _updateFractalBoss(b, W, H, WALL) {
        const cfg = BOSS_CONFIGS.fractal;
        for (let piece of b.pieces) {
          if (!piece.alive) continue;
          piece.rotation += 0.03;
          piece.x+=piece.vx; piece.y+=piece.vy;
          const pad=piece.radius+10;
          if (piece.x-pad<WALL)   {piece.x=WALL+pad;   piece.vx= Math.abs(piece.vx);}
          if (piece.x+pad>W-WALL) {piece.x=W-WALL-pad; piece.vx=-Math.abs(piece.vx);}
          if (piece.y-pad<WALL)   {piece.y=WALL+pad;   piece.vy= Math.abs(piece.vy);}
          if (piece.y+pad>H-WALL) {piece.y=H-WALL-pad; piece.vy=-Math.abs(piece.vy);}
          for (let p of this.players) {
            if (!p.alive||!p.connected) continue;
            const dx=p.x-piece.x,dy=p.y-piece.y;
            if (Math.sqrt(dx*dx+dy*dy)<piece.radius+this.PLAYER_SIZE/2){
              p.hp-=0.8;
              if (p.hp<=0&&p.alive){p.alive=false;p.hp=0;this.checkGameOver();}
            }
          }
          if (piece.hp<=0&&piece.alive) {
            piece.alive=false;
            this.triggerExplosion(piece.x,piece.y,'#ffdd00');
            if (piece.radius > cfg.splitThreshold) {
              for (let i=0;i<cfg.splitCount;i++) {
                const a=(i/cfg.splitCount)*Math.PI*2+Math.random()*0.5;
                const nr=Math.round(piece.radius*cfg.splitScale);
                const newHp = Math.ceil(piece.maxHp*0.6);
                b.pieces.push({
                  x:piece.x+Math.cos(a)*nr, y:piece.y+Math.sin(a)*nr,
                  vx:Math.cos(a)*2+Math.random()-0.5,
                  vy:Math.sin(a)*2+Math.random()-0.5,
                  rotation:0, hp:newHp, maxHp:newHp, radius:nr, alive:true
                });
              }
            }
          }
        }
        const alive=b.pieces.filter(p=>p.alive);
        if (alive.length>0){
          b.x=alive.reduce((s,p)=>s+p.x,0)/alive.length;
          b.y=alive.reduce((s,p)=>s+p.y,0)/alive.length;
        }
        if (b.pieces.every(p=>!p.alive)&&!b.dead) this._bossKill(b);
      }

      showBanner(text, color = '#ff0000') {
        const el = document.getElementById('wave-banner');
        el.textContent = text;
        el.style.color = color;
        el.style.textShadow = `0 0 20px ${color}`;
        el.style.display = 'block';
        setTimeout(() => { el.style.display = 'none'; }, 4000);
      }

      spawnZombie() {
        const side = Math.floor(Math.random() * 4);
        const W = this.canvas.width, H = this.canvas.height;
        let x, y;
        if      (side === 0) { x = Math.random()*W; y = -50; }
        else if (side === 1) { x = W+50; y = Math.random()*H; }
        else if (side === 2) { x = Math.random()*W; y = H+50; }
        else                 { x = -50; y = Math.random()*H; }
        const type     = this.rollZombieType();
        const typeData = ZOMBIE_TYPES[type];
        // CoD-style scaling: HP +15% per wave, speed +4% per wave
        const hpMult    = 1 + (this.wave - 1) * 0.15;
        const speedMult = 1 + (this.wave - 1) * 0.04;
        const scaledHp    = Math.round(typeData.hp * hpMult);
        const scaledSpeed = typeData.speed * speedMult;
        const hitRadius = type === 'runner' ? typeData.size * 0.875 : typeData.size / 2;
        this.zombies.push({
          x, y, type,
          hp: scaledHp, maxHp: scaledHp,
          speed: scaledSpeed, size: typeData.size,
          color: typeData.color, borderColor: typeData.borderColor,
          points: typeData.points,
          hitRadius,
        });
      }

      rollZombieType() {
        const weights = {
          regular: 70,
          runner:  20,
          tank:    10,
          bomber:  this.wave > 5 ? 15 : 0
        };
        const total = Object.values(weights).reduce((s, w) => s + w, 0);
        let roll = Math.random() * total;
        for (let type in weights) { roll -= weights[type]; if (roll <= 0) return type; }
        return 'regular';
      }

      fireBullet(p) {
        const weapon  = WEAPONS[p.currentWeapon];
        const damage  = this.getEffectiveDamage(p, weapon.damage); // tier multiplier applied here
        const bx = p.x + Math.cos(p.angle) * this.PLAYER_SIZE;
        const by = p.y + Math.sin(p.angle) * this.PLAYER_SIZE;
        const w  = p.currentWeapon;

        if (w === 'shotgun') {
          for (let i = 0; i < 6; i++) {
            const spread = (Math.random() - 0.5) * 0.55;
            const a = p.angle + spread;
            this.bullets.push({
              x: bx, y: by,
              vx: Math.cos(a) * this.BULLET_SPEED * (0.8 + Math.random() * 0.4),
              vy: Math.sin(a) * this.BULLET_SPEED * (0.8 + Math.random() * 0.4),
              damage, color: p.color, weapon: w, owner: p,
              life: 18 + Math.floor(Math.random() * 8)
            });
          }
        } else {
          this.bullets.push({
            x: bx, y: by,
            vx: Math.cos(p.angle) * this.BULLET_SPEED,
            vy: Math.sin(p.angle) * this.BULLET_SPEED,
            damage, color: p.color, weapon: w, owner: p
          });
        }

        this.spawnMuzzleEffect(bx, by, p.angle, w, p.color);
        if (p.ammo !== Infinity) p.ammo--;
      }

      spawnMuzzleEffect(x, y, angle, weapon, playerColor) {
        switch(weapon) {
          case 'pistol': {
            this._emitParticle(x, y, Math.cos(angle)*6, Math.sin(angle)*6, '#ffffff', 4, 4);
            for (let i = 0; i < 3; i++) {
              const a = angle + (Math.random()-0.5)*0.5;
              this._emitParticle(x, y, Math.cos(a)*(3+Math.random()*3), Math.sin(a)*(3+Math.random()*3), '#ffee88', 5, 2);
            }
            break;
          }
          case 'smg': {
            this._emitParticle(x, y, Math.cos(angle)*7, Math.sin(angle)*7, '#ffffff', 3, 3);
            for (let i = 0; i < 4; i++) {
              const a = angle + (Math.random()-0.5)*0.45;
              const s = 4 + Math.random()*4;
              this._emitParticle(x, y, Math.cos(a)*s, Math.sin(a)*s, i===0?'#ffffff':'#ffee44', 5, 2);
            }
            break;
          }
          case 'shotgun': {
            this._emitParticle(x, y, Math.cos(angle)*5, Math.sin(angle)*5, '#ffffff', 6, 10);
            this._emitParticle(x, y, Math.cos(angle)*3, Math.sin(angle)*3, '#ffaa00', 8, 7);
            for (let i = 0; i < 14; i++) {
              const a = angle + (Math.random()-0.5)*1.0;
              const s = 2 + Math.random()*6;
              const colors = ['#ffffff','#ffcc00','#ffaa00','#ff6600'];
              this._emitParticle(x, y, Math.cos(a)*s, Math.sin(a)*s, colors[Math.floor(Math.random()*colors.length)], 10+Math.random()*5|0, 2+Math.random()*3);
            }
            break;
          }
          case 'ar': {
            this._emitParticle(x, y, Math.cos(angle)*8, Math.sin(angle)*8, '#ffffff', 5, 6);
            for (let i = 0; i < 6; i++) {
              const a = angle + (Math.random()-0.5)*0.4;
              const s = 4 + Math.random()*5;
              this._emitParticle(x, y, Math.cos(a)*s, Math.sin(a)*s, i < 2?'#ffffff':'#ffcc00', 8, 2+Math.random()*2);
            }
            break;
          }
          case 'lmg': {
            this._emitParticle(x, y, Math.cos(angle)*7, Math.sin(angle)*7, '#ffffff', 5, 8);
            this._emitParticle(x, y, Math.cos(angle)*4, Math.sin(angle)*4, '#ff8800', 7, 6);
            for (let i = 0; i < 8; i++) {
              const a = angle + (Math.random()-0.5)*0.35;
              const s = 5 + Math.random()*5;
              this._emitParticle(x, y, Math.cos(a)*s, Math.sin(a)*s, i%3===0?'#ffffff':i%3===1?'#ffaa00':'#ffee00', 7, 2+Math.random()*3);
            }
            break;
          }
          case 'raygun': {
            for (let i = 0; i < 16; i++) {
              const a = angle + (Math.random()-0.5)*(i < 8 ? 0.3 : 1.2);
              const s = 3 + Math.random()*9;
              const colors = ['#00eeff','#00aaff','#aaf0ff','#ffffff','#0066ff'];
              this._emitParticle(x, y, Math.cos(a)*s, Math.sin(a)*s, colors[Math.floor(Math.random()*colors.length)], 8+Math.random()*8|0, 1+Math.random()*3);
            }
            this._emitParticle(x, y, Math.cos(angle)*10, Math.sin(angle)*10, '#ffffff', 4, 5);
            this._emitParticle(x, y, 0, 0, '#00eeff', 6, 8);
            break;
          }
          case 'thundergun': {
            this._emitParticle(x, y, 0, 0, '#ffffff', 8, 18);
            this._emitParticle(x, y, 0, 0, '#ff2200', 10, 14);
            for (let i = 0; i < 20; i++) {
              const a = (i / 20) * Math.PI * 2;
              const s = 4 + Math.random()*5;
              this._emitParticle(x, y, Math.cos(a)*s, Math.sin(a)*s, i%3===0?'#ffffff':'#ff2200', 20, 3+Math.random()*4);
            }
            break;
          }
        }
      }

      performMelee(p) {
        this.meleeFlashes.push({ x: p.x, y: p.y, angle: p.angle, timer: 8, color: p.color });

        for (let j = this.zombies.length - 1; j >= 0; j--) {
          const z  = this.zombies[j];
          const dx = z.x - p.x, dy = z.y - p.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist > MELEE_RANGE + (z.hitRadius??z.size/2)) continue;

          const angleToZombie = Math.atan2(dy, dx);
          let angleDiff = angleToZombie - p.angle;
          while (angleDiff >  Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          if (Math.abs(angleDiff) > MELEE_ARC / 2) continue;

          z.hp -= MELEE_DAMAGE;

          if (z.hp <= 0) {
            p.points += z.points;
            
            this.ammoPacks.push({ x: z.x, y: z.y });
            if (Math.random() < 0.08) this.healthPacks.push({ x: z.x, y: z.y });
            this.triggerExplosion(z.x, z.y, z.borderColor);
            if (z.type === 'bomber') this.triggerBomberExplosion(z.x, z.y);
            this.zombies.splice(j, 1);
            if (!z.spiralAdd) { // spiral adds don't count toward wave total
              this.waveKilled++;
              if (this.waveKilled >= this.waveTotal && this.zombies.filter(z=>!z.spiralAdd).length === 0) {
                this.wave++;
                setTimeout(() => this.startWave(), 3000);
              }
            }
          }
        }

        if (this.boss && !this.boss.dead && !this.boss.dropping) {
          const pts = this.getBossHitPoints();
          for (let t = 0; t < pts.length; t++) {
            const pt = pts[t];
            const dx = pt.x - p.x, dy = pt.y - p.y;
            const dist = Math.sqrt(dx*dx+dy*dy);
            if (dist > MELEE_RANGE + 20) continue;
            const angleToTip = Math.atan2(dy, dx);
            let angleDiff = angleToTip - p.angle;
            while (angleDiff >  Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            if (Math.abs(angleDiff) > MELEE_ARC / 2) continue;
            this._damageBossHitPoint(pt, MELEE_DAMAGE);
          }
        }
      }

      aabb(ax, ay, as, bx, by, bs) {
        return ax < bx+bs && ax+as > bx && ay < by+bs && ay+as > by;
      }

      // ── Particle pool helpers ───────────────────────────────────
      // Returns a dormant slot from the pool and marks it active by setting
      // its life, or returns null when all slots are in use (effect is silently skipped).
      _acquireParticle() {
        for (let i = 0; i < this.PARTICLE_POOL_SIZE; i++) {
          if (this.particles[i].life <= 0) return this.particles[i];
        }
        return null; // pool full — skip this particle
      }

      _emitParticle(x, y, vx, vy, color, life, size) {
        const pt = this._acquireParticle();
        if (!pt) return;
        pt.x=x; pt.y=y; pt.vx=vx; pt.vy=vy;
        pt.color=color; pt.life=life; pt.maxLife=life; pt.size=size;
      }

      spawnParticles(x, y, color, count = 12) {
        for (let i = 0; i < count; i++) {
          const angle  = Math.random() * Math.PI * 2;
          const speed  = 1.5 + Math.random() * 4;
          const life   = 20 + Math.floor(Math.random() * 20);
          this._emitParticle(x, y, Math.cos(angle)*speed, Math.sin(angle)*speed, color, life, 2 + Math.random() * 4);
        }
      }

      triggerExplosion(x, y, color) {
        this.spawnParticles(x, y, color);
        if (this.socket && this.roomCode) {
          this.socket.emit('explosion', { roomCode: this.roomCode, x, y, color });
        }
      }

      triggerBomberExplosion(bx, by, depth=0) {
        if (depth > BOMBER_CHAIN_DEPTH) return;
        for (let i = 0; i < 20; i++) {
          const a = (i / 20) * Math.PI * 2;
          const speed = 2 + Math.random() * 4;
          this._emitParticle(bx, by, Math.cos(a)*speed, Math.sin(a)*speed, i%2===0?'#4499ff':'#ffffff', 30+Math.random()*20, 5+Math.random()*5);
        }
        for (let p of this.players) {
          if (!p.alive || !p.connected) continue;
          const dx = p.x-bx, dy = p.y-by;
          if (Math.sqrt(dx*dx+dy*dy) < BOMBER_BLAST_RADIUS + this.PLAYER_SIZE/2) {
            p.hp -= BOMBER_PLAYER_DAMAGE;
            if (p.hp<=0&&p.alive){p.alive=false;p.hp=0;this.checkGameOver();}
          }
        }
        const toKill = [];
        for (let i = this.zombies.length-1; i >= 0; i--) {
          const z = this.zombies[i];
          const dx=z.x-bx, dy=z.y-by;
          if (Math.sqrt(dx*dx+dy*dy) < BOMBER_BLAST_RADIUS+z.size/2) toKill.push({idx:i,z});
        }
        const chainPositions = toKill.filter(({z})=>z.type==='bomber').map(({z})=>({x:z.x,y:z.y}));
        for (const {idx,z} of toKill) {
          this.triggerExplosion(z.x, z.y, z.borderColor);
          this.zombies.splice(idx,1);
          this.waveKilled++;
          if (this.waveKilled>=this.waveTotal&&this.zombies.length===0){this.wave++;setTimeout(()=>this.startWave(),3000);}
        }
        for (const pos of chainPositions) this.triggerBomberExplosion(pos.x,pos.y,depth+1);
      }

      updateRevive() {
        const now = Date.now();
        for (let reviver of this.players) {
          if (!reviver.alive || !reviver.connected) { this.reviveMap.delete(reviver.slot); continue; }
          let found = false;
          for (let target of this.players) {
            if (target.alive || !target.connected || target === reviver) continue;
            const dx = target.x-reviver.x, dy = target.y-reviver.y;
            if (Math.sqrt(dx*dx+dy*dy) <= this.REVIVE_RADIUS) {
              found = true;
              const attempt = this.reviveMap.get(reviver.slot);
              if (!attempt || attempt.targetSlot !== target.slot) {
                this.reviveMap.set(reviver.slot, { targetSlot: target.slot, startTime: now });
              } else if (now - attempt.startTime >= this.REVIVE_TIME) {
                target.alive = true; target.hp = 50;
                this.reviveMap.delete(reviver.slot);
              }
              break;
            }
          }
          if (!found) this.reviveMap.delete(reviver.slot);
        }
      }

      restart() {
        this.zombies=[]; this.bullets=[]; this.ammoPacks=[]; this.healthPacks=[];
        this.wave=1; this.waveTotal=0; this.waveKilled=0;
        for (const t of this._spawnTimeouts) clearTimeout(t);
        this._spawnTimeouts = [];
        this.gameOver=false; this.gameStarted=false;
        this.reviveMap.clear(); this.mysteryBox=null;
        this.vendingMachine=null; this.vendingCost=VENDING_BASE_COST;
        this.juggernogMachine=null; this.papMachine=null;
        this.meleeFlashes=[]; this.boss=null; this.isBossWave=false;
        // Reset pool: mark all slots inactive without reallocating
        for (let i = 0; i < this.PARTICLE_POOL_SIZE; i++) this.particles[i].life = 0;
        for (let p of this.players) { p.savedAmmo=undefined; }

        for (let p of this.players) {
          p.x=PLAYER_SPAWNS[p.slot-1].x; p.y=PLAYER_SPAWNS[p.slot-1].y;
          p.vx=0; p.vy=0; p.angle=0;
          p.hp=100; p.maxHp=100; p.ammo=30; p.points=0;
          p.currentWeapon='pistol'; p.alive=true;
          p.firing=false; p.fireCooldown=0;
          p.meleeing=false; p.meleeCooldown=0;
          
          p.hasJuggernog=false; p.papTier=0;
        }
        document.getElementById('game-over-screen').style.display  = 'none';
        document.getElementById('game-info').style.display         = 'none';
        document.getElementById('lobby-screen').style.display      = 'block';
        document.getElementById('countdown').style.display         = 'none';
        document.getElementById('vote-display').textContent        = 'Waiting for restart votes...';

        for (let i = 1; i <= 4; i++) {
          const slot   = document.getElementById(`slot-${i}`);
          const status = slot.querySelector('.slot-status');
          const player = this.players[i-1];
          if (player.connected) {
            slot.className='lobby-slot connected'; status.className='slot-status status-joined'; status.textContent='JOINED';
          } else {
            slot.className='lobby-slot'; status.className='slot-status status-waiting'; status.textContent='EMPTY';
          }
        }
      }

      update() {
        if (this.gameOver || !this.gameStarted) return;
        const W = this.canvas.width, H = this.canvas.height;
        const hs = this.PLAYER_SIZE / 2;

        for (let i = this.meleeFlashes.length-1; i >= 0; i--) {
          this.meleeFlashes[i].timer--;
          if (this.meleeFlashes[i].timer <= 0) this.meleeFlashes.splice(i,1);
        }

        for (let p of this.players) {
          if (!p.connected || !p.alive) continue;
          const WALL = 6;
          const clamp = hs + WALL;
          p.x = Math.max(clamp, Math.min(W-clamp, p.x+p.vx));
          p.y = Math.max(clamp, Math.min(H-clamp, p.y+p.vy));

          const weapon = WEAPONS[p.currentWeapon];
          p.fireCooldown--; p.meleeCooldown--;

          if (p.firing && (p.ammo>0||p.ammo===Infinity) && p.fireCooldown<=0) {
            this.fireBullet(p); p.fireCooldown=weapon.fireRate;
          }
          if (p.meleeing && p.ammo===0 && p.ammo!==Infinity && p.meleeCooldown<=0) {
            this.performMelee(p); p.meleeCooldown=1;
          }
        }

        for (let i = this.bullets.length-1; i >= 0; i--) {
          const b = this.bullets[i];
          b.x+=b.vx; b.y+=b.vy;
          if (b.life!==undefined){b.life--;if(b.life<=0){this.bullets.splice(i,1);continue;}}
          if (b.x<0||b.x>W||b.y<0||b.y>H){this.bullets.splice(i,1);continue;}
          let hit = false;
          for (let j = this.zombies.length-1; j >= 0; j--) {
            const z = this.zombies[j];
            const bdx=b.x-z.x, bdy=b.y-z.y;
            if (Math.sqrt(bdx*bdx+bdy*bdy) < (z.hitRadius??z.size/2)+this.BULLET_SIZE/2) {
              z.hp-=b.damage; hit=true;
              if (z.hp<=0){
                let nearest=null,nearestDist=Infinity;
                for (let p of this.players){if(!p.alive||!p.connected)continue;const dx=p.x-z.x,dy=p.y-z.y,dist=Math.sqrt(dx*dx+dy*dy);if(dist<nearestDist){nearestDist=dist;nearest=p;}}
                const killer = b.owner || nearest;
                if(killer){ killer.points+=z.points;  }
                if(Math.random()<this.AMMO_DROP_CHANCE)this.ammoPacks.push({x:z.x,y:z.y});
                if(Math.random()<0.08)this.healthPacks.push({x:z.x,y:z.y});
                this.triggerExplosion(z.x,z.y,z.borderColor);
                if(z.type==='bomber')this.triggerBomberExplosion(z.x,z.y);
                const wasSpiralAdd = z.spiralAdd;
                this.zombies.splice(j,1);
                if (!wasSpiralAdd) {
                  this.waveKilled++;
                  if(this.waveKilled>=this.waveTotal&&this.zombies.filter(z=>!z.spiralAdd).length===0){this.wave++;setTimeout(()=>this.startWave(),3000);}
                }
              }
              break;
            }
          }
          if(hit){this.bullets.splice(i,1);continue;}

          if (this.boss&&!this.boss.dead&&!this.boss.dropping) {
            const pts=this.getBossHitPoints();
            for (let t=0;t<pts.length;t++){
              const pt=pts[t],dx=b.x-pt.x,dy=b.y-pt.y;
              const hitR=pt.piece?Math.min(pt.radius*0.6,30):22;
              if(Math.sqrt(dx*dx+dy*dy)<hitR){
                hit=true; this._damageBossHitPoint(pt, b.damage);
                this.bullets.splice(i,1); break;
              }
            }
          }
          if(hit)this.bullets.splice(i,1);
        }

        for (let z of this.zombies) {
          let nearest=null,nearestDist=Infinity;
          for (let p of this.players){if(!p.alive||!p.connected)continue;const dx=p.x-z.x,dy=p.y-z.y,dist=Math.sqrt(dx*dx+dy*dy);if(dist<nearestDist){nearestDist=dist;nearest=p;}}
          if(!nearest)continue;
          const dx=nearest.x-z.x,dy=nearest.y-z.y,dist=Math.sqrt(dx*dx+dy*dy);
          const zr=z.hitRadius??z.size/2,pr=this.PLAYER_SIZE/2,minDist=zr+pr;
          if(dist>minDist&&dist>0){z.x+=(dx/dist)*z.speed;z.y+=(dy/dist)*z.speed;}
          else if(dist<minDist&&dist>0){z.x=nearest.x-(dx/dist)*minDist;z.y=nearest.y-(dy/dist)*minDist;}
          const zpDx=nearest.x-z.x,zpDy=nearest.y-z.y;
          if(Math.sqrt(zpDx*zpDx+zpDy*zpDy)<minDist){nearest.hp-=0.5;if(nearest.hp<=0&&nearest.alive){nearest.alive=false;nearest.hp=0;this.checkGameOver();}}
        }

        for (let i=this.ammoPacks.length-1;i>=0;i--){
          const a=this.ammoPacks[i],hs2=this.PLAYER_SIZE/2;
          for (let p of this.players){if(!p.alive)continue;if(this.aabb(a.x-this.AMMO_SIZE/2,a.y-this.AMMO_SIZE/2,this.AMMO_SIZE,p.x-hs2,p.y-hs2,this.PLAYER_SIZE)){const weapon=WEAPONS[p.currentWeapon];p.ammo+=Math.floor(weapon.ammoCapacity*0.5);this.ammoPacks.splice(i,1);break;}}
        }
        // Cap pack arrays — oldest packs beyond the limit are silently dropped
        if (this.ammoPacks.length  > 30) this.ammoPacks.splice(0,  this.ammoPacks.length  - 30);
        if (this.healthPacks.length > 20) this.healthPacks.splice(0, this.healthPacks.length - 20);

        for (let i = 0; i < this.PARTICLE_POOL_SIZE; i++) {
          const pt = this.particles[i];
          if (pt.life <= 0) continue;
          pt.x+=pt.vx; pt.y+=pt.vy; pt.vx*=0.92; pt.vy*=0.92; pt.life--;
        }

        for (let i=this.healthPacks.length-1;i>=0;i--){
          const h=this.healthPacks[i];
          for (let p of this.players){if(!p.alive)continue;const hs2=this.PLAYER_SIZE/2;if(this.aabb(h.x-10,h.y-10,20,p.x-hs2,p.y-hs2,this.PLAYER_SIZE)){p.hp=Math.min(p.maxHp,p.hp+30);this.healthPacks.splice(i,1);break;}}
        }

        this.updateRevive();
        this.updateBoss();
      }

      checkGameOver() {
        const anyAlive = this.players.some(p => p.alive && p.connected);
        if (!anyAlive) {
          this.gameOver = true;
          document.getElementById('game-over-screen').style.display = 'block';
        }
      }

      render() {
        const ctx = this.ctx;
        const W = this.canvas.width, H = this.canvas.height;
        const hs = this.PLAYER_SIZE / 2;

        ctx.drawImage(this._gridCanvas, 0, 0);

        if (this.mysteryBox) {
          const bhs = this.BOX_SIZE / 2;
          ctx.shadowColor='#bb00ff'; ctx.shadowBlur=20;
          ctx.fillStyle='#bb00ff'; ctx.fillRect(this.mysteryBox.x-bhs,this.mysteryBox.y-bhs,this.BOX_SIZE,this.BOX_SIZE);
          ctx.shadowBlur=0; ctx.strokeStyle='#ff00ff'; ctx.lineWidth=3;
          ctx.strokeRect(this.mysteryBox.x-bhs,this.mysteryBox.y-bhs,this.BOX_SIZE,this.BOX_SIZE);
          ctx.fillStyle='#fff'; ctx.font='bold 32px Courier New'; ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText('?',this.mysteryBox.x,this.mysteryBox.y);
        }

        // ── Vending machine ────────────────────────────────────────
        if (this.vendingMachine) {
          const v = this.vendingMachine;
          const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 400);
          ctx.save();
          ctx.fillStyle = '#0a1a0a';
          ctx.strokeStyle = `rgba(0,255,100,${0.4 + pulse * 0.3})`;
          ctx.lineWidth = 3;
          ctx.shadowColor = '#00ff66';
          ctx.shadowBlur = 12 * pulse;
          ctx.beginPath(); ctx.roundRect(v.x-28, v.y-36, 56, 72, 6); ctx.fill(); ctx.stroke();
          ctx.shadowBlur = 0;
          // health cross
          ctx.fillStyle = '#00ff66';
          ctx.fillRect(v.x-4, v.y-20, 8, 22);
          ctx.fillRect(v.x-12, v.y-11, 24, 8);
          // price
          ctx.font = 'bold 13px Courier New'; ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillStyle = '#00ff66';
          ctx.fillText('$'+this.vendingCost, v.x, v.y+18);
          ctx.font = '10px Courier New';
          ctx.fillStyle = '#336633';
          ctx.fillText('+'+VENDING_HEAL_AMOUNT+' HP', v.x, v.y+30);
          ctx.restore();
        }

        // ── Juggernog machine ──────────────────────────────────────
        if (this.juggernogMachine) {
          const j = this.juggernogMachine;
          const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 500 + 1);
          ctx.save();
          ctx.fillStyle = '#1a0005';
          ctx.strokeStyle = `rgba(255,50,100,${0.4 + pulse * 0.3})`;
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ff3366';
          ctx.shadowBlur = 12 * pulse;
          ctx.beginPath(); ctx.roundRect(j.x-28, j.y-36, 56, 72, 6); ctx.fill(); ctx.stroke();
          ctx.shadowBlur = 0;
          // Juggernog icon: shield shape
          ctx.fillStyle = '#ff3366';
          ctx.beginPath();
          ctx.moveTo(j.x, j.y-22); ctx.lineTo(j.x+14, j.y-14);
          ctx.lineTo(j.x+14, j.y); ctx.lineTo(j.x, j.y+14);
          ctx.lineTo(j.x-14, j.y); ctx.lineTo(j.x-14, j.y-14);
          ctx.closePath(); ctx.fill();
          ctx.fillStyle = '#1a0005';
          ctx.font = 'bold 14px Courier New'; ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText('J', j.x, j.y-4);
          // price
          ctx.font = 'bold 12px Courier New';
          ctx.fillStyle = '#ff3366';
          ctx.fillText('$'+JUGGERNOG_COST, j.x, j.y+18);
          ctx.font = '10px Courier New';
          ctx.fillStyle = '#662233';
          ctx.fillText('+'+JUGGERNOG_HP_BONUS+' HP MAX', j.x, j.y+30);
          ctx.restore();
        }

        // ── Pack-a-Punch machine ───────────────────────────────────
        if (this.papMachine) {
          const m = this.papMachine;
          const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 350 + 2);
          // find the cheapest tier any player can still buy (for label)
          const nextTierDef = PAP_TIERS[0]; // always show tier 1 cost on machine
          ctx.save();
          ctx.fillStyle = '#0a0015';
          ctx.strokeStyle = `rgba(180,80,255,${0.4 + pulse * 0.35})`;
          ctx.lineWidth = 3;
          ctx.shadowColor = '#cc44ff';
          ctx.shadowBlur = 14 * pulse;
          ctx.beginPath(); ctx.roundRect(m.x-32, m.y-40, 64, 80, 6); ctx.fill(); ctx.stroke();
          ctx.shadowBlur = 0;
          // PaP icon: fist/star
          ctx.fillStyle = '#cc44ff';
          ctx.font = 'bold 28px Courier New'; ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText('⚡', m.x, m.y-8);
          ctx.font = 'bold 11px Courier New';
          ctx.fillStyle = '#cc44ff';
          ctx.fillText('PACK-a-PUNCH', m.x, m.y+14);
          ctx.fillText('$'+PAP_TIERS[0].cost, m.x, m.y+27);
          ctx.restore();
        }
          ctx.fillStyle='#ffff00'; ctx.fillRect(a.x-this.AMMO_SIZE/2,a.y-this.AMMO_SIZE/2,this.AMMO_SIZE,this.AMMO_SIZE);
          ctx.strokeStyle='#ffaa00'; ctx.lineWidth=2; ctx.strokeRect(a.x-this.AMMO_SIZE/2,a.y-this.AMMO_SIZE/2,this.AMMO_SIZE,this.AMMO_SIZE);
          ctx.fillStyle='#000'; ctx.font='bold 12px Courier New'; ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText('A',a.x,a.y);
        }

        for (let h of this.healthPacks) {
          ctx.fillStyle='#222'; ctx.fillRect(h.x-10,h.y-10,20,20);
          ctx.strokeStyle='#ff4444'; ctx.lineWidth=2; ctx.strokeRect(h.x-10,h.y-10,20,20);
          ctx.fillStyle='#ff3333'; ctx.fillRect(h.x-7,h.y-2,14,4); ctx.fillRect(h.x-2,h.y-7,4,14);
        }

        for (let z of this.zombies) {
          const zhs=z.size/2,zx=z.x-zhs,zy=z.y-zhs;
          if (z.type==='bomber') {
            const pulse=0.7+0.3*Math.sin(Date.now()/200);
            ctx.save();
            ctx.shadowColor='#4499ff'; ctx.shadowBlur=15*pulse;
            ctx.fillStyle=`rgba(0,80,255,${0.8*pulse})`;
            ctx.beginPath(); ctx.arc(z.x,z.y,zhs,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle='#aaddff'; ctx.lineWidth=2;
            ctx.beginPath(); ctx.arc(z.x,z.y,zhs,0,Math.PI*2); ctx.stroke();
            ctx.shadowBlur=0;
            ctx.strokeStyle='#ffffff'; ctx.lineWidth=1.5; ctx.globalAlpha=pulse;
            ctx.beginPath(); ctx.moveTo(z.x-5,z.y); ctx.lineTo(z.x+5,z.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(z.x,z.y-5); ctx.lineTo(z.x,z.y+5); ctx.stroke();
            ctx.globalAlpha=1; ctx.restore();
          } else {
            ctx.fillStyle=z.color; ctx.fillRect(zx,zy,z.size,z.size);
            ctx.strokeStyle=z.borderColor; ctx.lineWidth=2; ctx.strokeRect(zx,zy,z.size,z.size);
          }
          ctx.fillStyle='#ff0000'; ctx.fillRect(z.x-zhs,zy-8,z.size,4);
          ctx.fillStyle='#00ff00'; ctx.fillRect(z.x-zhs,zy-8,z.size*(z.hp/z.maxHp),4);
        }

        for (let b of this.bullets) {
          ctx.save();
          switch(b.weapon) {
            case 'shotgun': ctx.fillStyle='#ffcc66'; ctx.shadowColor='#ffaa00'; ctx.shadowBlur=4; ctx.beginPath(); ctx.arc(b.x,b.y,2,0,Math.PI*2); ctx.fill(); break;
            case 'smg': { const a=Math.atan2(b.vy,b.vx); ctx.fillStyle='#ffee44'; ctx.shadowColor='#ffee44'; ctx.shadowBlur=6; ctx.translate(b.x,b.y); ctx.rotate(a); ctx.fillRect(-5,-1.5,10,3); break; }
            case 'lmg': { const a=Math.atan2(b.vy,b.vx); ctx.fillStyle='#ff8800'; ctx.shadowColor='#ffaa00'; ctx.shadowBlur=8; ctx.translate(b.x,b.y); ctx.rotate(a); ctx.fillRect(-7,-2,14,4); break; }
            case 'raygun': ctx.fillStyle='#00ccff'; ctx.shadowColor='#00ffff'; ctx.shadowBlur=20; ctx.beginPath(); ctx.arc(b.x,b.y,4,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#aaeeff'; ctx.lineWidth=1; ctx.globalAlpha=0.5; ctx.beginPath(); ctx.arc(b.x,b.y,7,0,Math.PI*2); ctx.stroke(); break;
            case 'thundergun': ctx.fillStyle='#ff2200'; ctx.shadowColor='#ff4400'; ctx.shadowBlur=30; ctx.beginPath(); ctx.arc(b.x,b.y,7,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#ffffff'; ctx.shadowBlur=10; ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill(); break;
            default: ctx.fillStyle=b.color; ctx.shadowColor=b.color; ctx.shadowBlur=8; ctx.beginPath(); ctx.arc(b.x,b.y,this.BULLET_SIZE/2,0,Math.PI*2); ctx.fill();
          }
          ctx.restore();
        }

        // ── Particles — batched by color, no shadowBlur, no save/restore per slot ──
        // Sort active particles by color so we minimise fillStyle switches.
        // Using fillRect (not arc) for the smallest particles avoids arc overhead.
        ctx.save();
        let lastColor = null;
        for (let i = 0; i < this.PARTICLE_POOL_SIZE; i++) {
          const pt = this.particles[i];
          if (pt.life <= 0) continue;
          const alpha = pt.life / pt.maxLife;
          if (pt.color !== lastColor) {
            ctx.fillStyle = pt.color;
            lastColor = pt.color;
          }
          ctx.globalAlpha = alpha;
          const r = pt.size * alpha;
          // fillRect is faster than arc for sub-4px particles
          if (r < 3) {
            const d = r * 2;
            ctx.fillRect(pt.x - r, pt.y - r, d, d);
          } else {
            ctx.beginPath(); ctx.arc(pt.x, pt.y, r, 0, Math.PI*2); ctx.fill();
          }
        }
        ctx.globalAlpha = 1;
        ctx.restore();

        for (let f of this.meleeFlashes) {
          const alpha=f.timer/8;
          ctx.save(); ctx.globalAlpha=alpha*0.55; ctx.fillStyle=f.color; ctx.shadowColor=f.color; ctx.shadowBlur=20;
          ctx.beginPath(); ctx.moveTo(f.x,f.y); ctx.arc(f.x,f.y,MELEE_RANGE,f.angle-MELEE_ARC/2,f.angle+MELEE_ARC/2); ctx.closePath(); ctx.fill(); ctx.restore();
        }

        // ── BOSS RENDER ───────────────────────────────────────────────
        if (this.boss && !this.boss.dead) {
          const b = this.boss;
          const flashing = b.flashTimer > 0 && b.flashTimer % 2 === 0;

          for (let bb of b.bossBullets) {
            ctx.save(); ctx.fillStyle=bb.color; ctx.shadowColor=bb.color; ctx.shadowBlur=10;
            ctx.beginPath(); ctx.arc(bb.x,bb.y,5,0,Math.PI*2); ctx.fill(); ctx.restore();
          }

          if (b.type==='triangle') {
            ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.rotation);
            ctx.beginPath();
            for(let i=0;i<3;i++){const a=-Math.PI/2+(i*2*Math.PI/3);i===0?ctx.moveTo(Math.cos(a)*b.radius,Math.sin(a)*b.radius):ctx.lineTo(Math.cos(a)*b.radius,Math.sin(a)*b.radius);}
            ctx.closePath(); ctx.fillStyle=flashing?'#ffffff':b.color; ctx.shadowColor='#bb00ff'; ctx.shadowBlur=30; ctx.fill();
            ctx.strokeStyle='#000'; ctx.lineWidth=4; ctx.stroke(); ctx.shadowBlur=0; ctx.restore();
            const tAngles=[b.rotation-Math.PI/2,b.rotation-Math.PI/2+(2*Math.PI/3),b.rotation-Math.PI/2+(4*Math.PI/3)];
            for(let t=0;t<3;t++){
              if(b.tips[t].hp<=0)continue;
              const tx=b.x+Math.cos(tAngles[t])*b.radius,ty=b.y+Math.sin(tAngles[t])*b.radius;
              const tipSize=18+(b.tips[t].hp/b.tips[t].maxHp)*10;
              ctx.save(); ctx.translate(tx,ty); ctx.rotate(tAngles[t]);
              ctx.beginPath(); ctx.moveTo(0,-tipSize); ctx.lineTo(-tipSize*0.8,tipSize*0.6); ctx.lineTo(tipSize*0.8,tipSize*0.6); ctx.closePath();
              ctx.fillStyle=flashing?'#ffaaaa':'#cc0000'; ctx.shadowColor='#ff0000'; ctx.shadowBlur=15; ctx.fill();
              ctx.strokeStyle='#000'; ctx.lineWidth=2; ctx.stroke(); ctx.shadowBlur=0;
              ctx.fillStyle='#330000'; ctx.fillRect(-20,tipSize+4,40,5);
              ctx.fillStyle='#ff0000'; ctx.fillRect(-20,tipSize+4,40*(b.tips[t].hp/b.tips[t].maxHp),5);
              ctx.restore();
            }

          } else if (b.type==='octagon') {
            ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.rotation);
            ctx.beginPath();
            for(let i=0;i<8;i++){const a=(i/8)*Math.PI*2;i===0?ctx.moveTo(Math.cos(a)*b.radius,Math.sin(a)*b.radius):ctx.lineTo(Math.cos(a)*b.radius,Math.sin(a)*b.radius);}
            ctx.closePath(); ctx.fillStyle=flashing?'#ffffff':'#cc4400'; ctx.shadowColor='#ff6600'; ctx.shadowBlur=25; ctx.fill();
            ctx.strokeStyle='#ff9900'; ctx.lineWidth=3; ctx.stroke(); ctx.shadowBlur=0; ctx.restore();
            for(let i=0;i<8;i++){
              if(b.corners[i].hp<=0)continue;
              const a=b.rotation+(i/8)*Math.PI*2,cx=b.x+Math.cos(a)*b.radius,cy=b.y+Math.sin(a)*b.radius;
              const r=8+(b.corners[i].hp/b.corners[i].maxHp)*6;
              ctx.save(); ctx.fillStyle=flashing?'#fff':'#ff4400'; ctx.shadowColor='#ff6600'; ctx.shadowBlur=12;
              ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.restore();
            }

          } else if (b.type==='pentagon') {
            ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(b.rotation);

            // Orbiting panels (not dead, not flying)
            for (let i = 0; i < 5; i++) {
              const panel = b.panels[i];
              if (panel.state === 'dead' || panel.state === 'flying') continue;
              const aStart = (i/5)*Math.PI*2 - Math.PI/2;
              const aEnd   = ((i+1)/5)*Math.PI*2 - Math.PI/2;
              const gap    = 0.18;
              const hp_r   = panel.hp / panel.maxHp;
              ctx.beginPath(); ctx.moveTo(0,0);
              ctx.arc(0, 0, b.radius, aStart+gap, aEnd-gap);
              ctx.closePath();
              ctx.fillStyle   = flashing ? '#ffffff' : `rgba(0,${Math.floor(80+140*hp_r)},255,0.85)`;
              ctx.shadowColor = '#00aaff'; ctx.shadowBlur = 18;
              ctx.fill();
              ctx.strokeStyle = '#0055ff'; ctx.lineWidth = 2; ctx.stroke();
            }

            // Core — blue in normal phase, exposed+pulsing in rage
            ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI*2);
            if (b.rage) {
              const rp = 0.6 + 0.4*Math.sin(Date.now()/80);
              ctx.fillStyle   = flashing ? '#ffffff' : `rgba(0,${Math.floor(100*rp)},255,1)`;
              ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 30*rp;
              // Core HP bar in rage
              ctx.fill(); ctx.restore();
              const bw = 60, hp_r = b.coreHp / b.coreMaxHp;
              ctx.fillStyle = '#001133'; ctx.fillRect(b.x-bw/2, b.y+38, bw, 5);
              ctx.fillStyle = '#00aaff'; ctx.fillRect(b.x-bw/2, b.y+38, bw*hp_r, 5);
            } else {
              ctx.fillStyle   = flashing ? '#ffffff' : '#003388';
              ctx.shadowColor = '#00aaff'; ctx.shadowBlur = 0;
              ctx.fill(); ctx.restore();
            }

            // Flying boomerang panel
            if (b.boomerang && b.activePanel >= 0) {
              const bm  = b.boomerang;
              const rot = bm.t * Math.PI * 4; // spins as it flies
              const hp_r = b.panels[b.activePanel].hp / b.panels[b.activePanel].maxHp;
              ctx.save(); ctx.translate(bm.x, bm.y); ctx.rotate(rot);
              // Panel as a wedge shape
              ctx.beginPath();
              ctx.arc(0, 0, 28, -Math.PI/4, Math.PI/4);
              ctx.lineTo(0, 0); ctx.closePath();
              ctx.fillStyle   = flashing ? '#ffffff' : `rgba(0,${Math.floor(80+140*hp_r)},255,0.9)`;
              ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 25;
              ctx.fill();
              ctx.strokeStyle = '#00ddff'; ctx.lineWidth = 2; ctx.stroke();
              ctx.shadowBlur = 0;
              // Trail dot
              ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2);
              ctx.fillStyle = '#ffffff'; ctx.fill();
              ctx.restore();
            }

          } else if (b.type==='diamond') {
            if (!b.split) {
              ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.rotation);
              ctx.beginPath(); ctx.moveTo(0,-b.radius); ctx.lineTo(b.radius*0.6,0); ctx.lineTo(0,b.radius); ctx.lineTo(-b.radius*0.6,0); ctx.closePath();
              const hp_ratio=b.coreHp/b.coreMaxHp;
              ctx.fillStyle=flashing?'#ffffff':`hsl(${320+40*hp_ratio},100%,50%)`;
              ctx.shadowColor='#ff44aa'; ctx.shadowBlur=30; ctx.fill(); ctx.strokeStyle='#ff88cc'; ctx.lineWidth=3; ctx.stroke(); ctx.shadowBlur=0;
              ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(-30,-5,60,10);
              ctx.fillStyle='#ff44aa'; ctx.fillRect(-30,-5,60*hp_ratio,10); ctx.restore();
            } else {
              for(let s of b.shards){
                if(!s.alive)continue;
                ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.rotation);
                ctx.beginPath(); ctx.moveTo(0,-s.radius); ctx.lineTo(s.radius*0.6,0); ctx.lineTo(0,s.radius); ctx.lineTo(-s.radius*0.6,0); ctx.closePath();
                ctx.fillStyle=flashing?'#ffffff':'#cc2288'; ctx.shadowColor='#ff44aa'; ctx.shadowBlur=20; ctx.fill();
                ctx.strokeStyle='#ff88cc'; ctx.lineWidth=2; ctx.stroke(); ctx.shadowBlur=0;
                const bw=s.radius*1.2;
                ctx.fillStyle='#330011'; ctx.fillRect(-bw/2,s.radius+4,bw,4);
                ctx.fillStyle='#ff44aa'; ctx.fillRect(-bw/2,s.radius+4,bw*(s.hp/s.maxHp),4); ctx.restore();
              }
            }

          } else if (b.type==='spiral') {
            // Consume flash — whole boss pulses red when eating zombies
            const consumePulse = b.consumeFlash > 0;
            ctx.save(); ctx.translate(b.x,b.y);
            for(let i=0;i<5;i++){
              const arm = b.arms[i];
              if(arm.hp<=0)continue;
              const regrowing = arm.regrowing > 0;
              if (arm.regrowing > 0) arm.regrowing--;
              const armA=b.rotation+(i/5)*Math.PI*2,ext=b.radius+60+Math.sin(b.breathe+i)*30,hp_r=arm.hp/arm.maxHp;
              ctx.save();
              const armColor = regrowing ? '#ff2200' : consumePulse ? '#ff4444' : flashing ? '#ffffff' : `hsl(150,100%,${40+30*hp_r}%)`;
              const armGlow  = regrowing ? '#ff0000' : consumePulse ? '#ff0000' : '#44ffaa';
              ctx.strokeStyle=armColor; ctx.lineWidth=6+(1-hp_r)*4; ctx.shadowColor=armGlow; ctx.shadowBlur= regrowing ? 25 : 15;
              ctx.beginPath(); const midA=armA+0.4,mx=Math.cos(midA)*ext*0.6,my=Math.sin(midA)*ext*0.6;
              ctx.moveTo(0,0); ctx.quadraticCurveTo(mx,my,Math.cos(armA)*ext,Math.sin(armA)*ext); ctx.stroke(); ctx.restore();
              const tipX=Math.cos(armA)*ext,tipY=Math.sin(armA)*ext;
              ctx.save(); ctx.fillStyle=regrowing?'#ff2200':consumePulse?'#ff4444':flashing?'#fff':'#00ff88'; ctx.shadowColor=regrowing?'#ff0000':consumePulse?'#ff0000':'#44ffaa'; ctx.shadowBlur=20;
              ctx.beginPath(); ctx.arc(tipX,tipY,8+hp_r*6,0,Math.PI*2); ctx.fill(); ctx.restore();
              ctx.save(); ctx.fillStyle='#003311'; ctx.fillRect(tipX-20,tipY+16,40,4);
              ctx.fillStyle='#44ffaa'; ctx.fillRect(tipX-20,tipY+16,40*hp_r,4); ctx.restore();
            }
            ctx.beginPath(); ctx.arc(0,0,25,0,Math.PI*2);
            ctx.fillStyle=consumePulse?'#ff2200':flashing?'#ffffff':'#006633';
            ctx.shadowColor=consumePulse?'#ff0000':'#44ffaa'; ctx.shadowBlur=20; ctx.fill(); ctx.restore();

            // Consuming zombies — suck-in animation: shrink & fly to boss center
            if (b.consumingZombies && b.consumingZombies.length > 0) {
              for (const cz of b.consumingZombies) {
                const scale = Math.max(0.15, 1 - cz.t * 0.85); // shrink as they're pulled in
                const sz = cz.size * scale;
                ctx.save();
                ctx.globalAlpha = 1 - cz.t * 0.5;
                ctx.fillStyle = cz.color;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.fillRect(cz.x - sz/2, cz.y - sz/2, sz, sz);
                ctx.strokeRect(cz.x - sz/2, cz.y - sz/2, sz, sz);
                ctx.restore();
              }
            }

            // Summon phase label
            if (b.summonPhase==='summoning') {
              const secs = Math.ceil(b.summonKillTimer / 60);
              ctx.save();
              ctx.fillStyle='#ffff00'; ctx.font='bold 11px Courier New';
              ctx.textAlign='center'; ctx.textBaseline='middle';
              ctx.fillText(`KILL ADDS ${secs}s`, b.x, b.y-b.radius-30);
              ctx.restore();
            }

          } else if (b.type==='fractal') {
            for(let piece of b.pieces){
              if(!piece.alive)continue;
              ctx.save(); ctx.translate(piece.x,piece.y); ctx.rotate(piece.rotation);
              ctx.beginPath();
              for(let i=0;i<3;i++){const a=-Math.PI/2+(i*2*Math.PI/3);i===0?ctx.moveTo(Math.cos(a)*piece.radius,Math.sin(a)*piece.radius):ctx.lineTo(Math.cos(a)*piece.radius,Math.sin(a)*piece.radius);}
              ctx.closePath();
              const hp_r=piece.hp/piece.maxHp;
              ctx.fillStyle=flashing?'#ffffff':`hsl(50,100%,${30+30*hp_r}%)`;
              ctx.shadowColor='#ffdd00'; ctx.shadowBlur=20; ctx.fill(); ctx.strokeStyle='#ffaa00'; ctx.lineWidth=2; ctx.stroke(); ctx.shadowBlur=0;
              const bw=piece.radius*1.4;
              ctx.fillStyle='#332200'; ctx.fillRect(-bw/2,piece.radius+4,bw,4);
              ctx.fillStyle='#ffdd00'; ctx.fillRect(-bw/2,piece.radius+4,bw*hp_r,4); ctx.restore();
            }
          }

          ctx.fillStyle='#ff44ff'; ctx.font='bold 16px Courier New'; ctx.textAlign='center'; ctx.textBaseline='middle';
          if (!b.dropping) ctx.fillText(b.label||'BOSS', b.x, b.y-(b.radius||80)-20);
        }

        ctx.strokeStyle='#00ff00'; ctx.lineWidth=4; ctx.shadowColor='#00ff00'; ctx.shadowBlur=14;
        ctx.strokeRect(2,2,W-4,H-4); ctx.shadowBlur=0;

        for (let p of this.players) {
          if (!p.connected) continue;
          if (p.alive) {
            // PaP glow — outer ring shows tier color
            if (p.papTier > 0) {
              const papColor = PAP_TIERS[p.papTier-1].color;
              ctx.shadowColor = papColor; ctx.shadowBlur = 22;
              ctx.strokeStyle = papColor; ctx.lineWidth = 2;
              ctx.strokeRect(p.x-hs-3, p.y-hs-3, this.PLAYER_SIZE+6, this.PLAYER_SIZE+6);
              ctx.shadowBlur = 0;
            }
            ctx.shadowColor=p.color; ctx.shadowBlur=15; ctx.fillStyle=p.color;
            ctx.fillRect(p.x-hs,p.y-hs,this.PLAYER_SIZE,this.PLAYER_SIZE); ctx.shadowBlur=0;
            ctx.strokeStyle='#fff'; ctx.lineWidth=2;
            ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+Math.cos(p.angle)*(hs+12),p.y+Math.sin(p.angle)*(hs+12)); ctx.stroke();
            ctx.fillStyle='#ff0000'; ctx.fillRect(p.x-hs,p.y-hs-10,this.PLAYER_SIZE,5);
            ctx.fillStyle='#00ff00'; ctx.fillRect(p.x-hs,p.y-hs-10,this.PLAYER_SIZE*(p.hp/p.maxHp),5);
            ctx.fillStyle='#ffff00'; ctx.font='bold 12px Courier New'; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText(`$${p.points}`,p.x,p.y-hs-20);
            // Juggernog indicator (small shield above $)
            if (p.hasJuggernog) {
              ctx.fillStyle='#ff3366'; ctx.font='10px Courier New';
              ctx.fillText('❤', p.x + 24, p.y-hs-20);
            }
            if(p.ammo===0){ctx.fillStyle='#00ff66';ctx.font='bold 11px Courier New';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText('KNIFE',p.x,p.y-hs-32);}
          } else {
            ctx.fillStyle='#444'; ctx.fillRect(p.x-hs,p.y-hs,this.PLAYER_SIZE,this.PLAYER_SIZE);
            ctx.strokeStyle='#888'; ctx.lineWidth=2; ctx.setLineDash([4,4]); ctx.strokeRect(p.x-hs,p.y-hs,this.PLAYER_SIZE,this.PLAYER_SIZE); ctx.setLineDash([]);
            for(let[,attempt]of this.reviveMap){
              if(attempt.targetSlot===p.slot){
                const progress=Math.min((Date.now()-attempt.startTime)/this.REVIVE_TIME,1);
                ctx.strokeStyle='#00ffff'; ctx.lineWidth=4;
                ctx.beginPath(); ctx.arc(p.x,p.y,hs+8,-Math.PI/2,-Math.PI/2+Math.PI*2*progress); ctx.stroke();
              }
            }
          }
          ctx.fillStyle='#fff'; ctx.font='bold 13px Courier New'; ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText('P'+p.slot,p.x,p.y);
        }

        this.updateHUD();
      }

      updateHUD() {
        if (++this._hudFrame % 10 !== 0) return;
        document.getElementById('wave').textContent         = this.wave;
        document.getElementById('zombie-count').textContent = this.zombies.length;
        document.getElementById('player-count').textContent = this.connectedCount();
      }

      canUseMysteryBox(player) {
        if (!this.mysteryBox||!player.alive) return false;
        const dx=player.x-this.mysteryBox.x,dy=player.y-this.mysteryBox.y;
        return Math.sqrt(dx*dx+dy*dy)<=BOX_USE_RANGE;
      }

      canUseVending(player) {
        if (!this.vendingMachine||!player.alive) return false;
        const dx=player.x-this.vendingMachine.x,dy=player.y-this.vendingMachine.y;
        return Math.sqrt(dx*dx+dy*dy)<=VENDING_USE_RANGE;
      }

      start() {
        let lastTime = 0;
        const frameDelay = 1000 / 60;
        let broadcastFrame = 0;
        const loop = (currentTime) => {
          const deltaTime = currentTime - lastTime;
          if (deltaTime >= frameDelay) {
            this.update();
            this.render();
            // Broadcast at 20hz (every 3 frames) — controllers don't need 60hz state
            if (this.socket && this.roomCode && ++broadcastFrame % 3 === 0) {
              this.socket.emit('game-state-broadcast', {
                roomCode: this.roomCode,
                gameState: {
                  wave: this.wave,
                  zombiesRemaining: this.zombies.length,
                  gameOver: this.gameOver,
                  players: this.players.map(p => ({
                    health: p.hp,
                    maxHp: p.maxHp,
                    ammo: p.ammo === Infinity ? -1 : p.ammo,
                    isAlive: p.alive,
                    points: p.points,
                    weapon: p.currentWeapon,
                    canUseMysteryBox: this.canUseMysteryBox(p),
                    canUseVending: this.canUseVending(p),
                    canUseJuggernog: this.canUseJuggernog(p),
                    canUsePap: this.canUsePap(p),
                    vendingCost: this.vendingCost,
                    papTier: p.papTier,
                    hasJuggernog: p.hasJuggernog,
                    nextPapCost: p.papTier < PAP_TIERS.length ? PAP_TIERS[p.papTier].cost : null,
                  }))
                }
              });
            }
            lastTime = currentTime - (deltaTime % frameDelay);
          }
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    const game   = new GameEngine();
    const socket = io({ transports: ['websocket'] });
    game.socket  = socket;

    socket.on('connect', () => socket.emit('create-room'));
    socket.on('room-created', (data) => {
      game.roomCode = data.roomCode;
      document.getElementById('room-code').textContent = data.roomCode;
      const qrUrl = `${window.location.origin}/controller.html?room=${data.roomCode}`;
      const canvas = document.createElement('canvas');
      document.getElementById('qr-code').innerHTML = '';
      document.getElementById('qr-code').appendChild(canvas);
      QRCode.toCanvas(canvas, qrUrl, { width: 128, margin: 1, color: { dark: '#000000', light: '#ffffff' } });
      game.start();
    });

    socket.on('explosion',            (d) => game.spawnParticles(d.x, d.y, d.color));
    socket.on('player-joined',        (d) => game.addPlayer(d.slotNumber));
    socket.on('player-disconnected',  (d) => game.removePlayer(d.slotNumber));
    socket.on('player-removed',       (d) => game.removePlayer(d.slotNumber));
    socket.on('player-input',         (d) => game.handleInput(d.slotNumber, d.input));
    socket.on('mystery-box-purchase', (d) => game.handleMysteryBoxPurchase(d.slotNumber));
    socket.on('vending-purchase',     (d) => game.handleVendingPurchase(d.slotNumber));
    socket.on('juggernog-purchase',   (d) => game.handleJuggernogPurchase(d.slotNumber));
    socket.on('pap-purchase',         (d) => game.handlePapPurchase(d.slotNumber));
    socket.on('lobby-update',         (d) => game.updateLobby(d.players));
    socket.on('ready-countdown', (d) => {
      const el = document.getElementById('countdown');
      el.style.display='block'; el.textContent=d.seconds;
      el.style.animation='none'; el.offsetHeight; el.style.animation='pop 0.3s ease';
    });
    socket.on('ready-countdown-cancelled', () => {
      document.getElementById('countdown').style.display = 'none';
    });
    socket.on('all-ready', () => game.beginGame());
    socket.on('restart-game', () => game.restart());
    socket.on('restart-vote-update', (d) => {
      document.getElementById('vote-display').textContent =
        `Restart votes: ${d.votes} / ${d.needed} - Vote YES on your phone!`;
    });


    const BASE_W = 1334;
    const BASE_H = 750;

    function scaleCanvas() {
      const container = document.getElementById('game-container');
      const canvas    = document.getElementById('canvas');
      const scale = Math.min(window.innerWidth / BASE_W, window.innerHeight / BASE_H);
      canvas.width  = BASE_W;
      canvas.height = BASE_H;
      container.style.width     = BASE_W + 'px';
      container.style.height    = BASE_H + 'px';
      container.style.transform = `scale(${scale})`;
      container.style.transformOrigin = 'top left';
      const scaledW = BASE_W * scale;
      const scaledH = BASE_H * scale;
      container.style.position = 'absolute';
      container.style.left = Math.floor((window.innerWidth  - scaledW) / 2) + 'px';
      container.style.top  = Math.floor((window.innerHeight - scaledH) / 2) + 'px';
    }

    scaleCanvas();
    window.addEventListener('resize', scaleCanvas);
    window.addEventListener('orientationchange', () => setTimeout(scaleCanvas, 100));

  </script>
</body>
</html>
