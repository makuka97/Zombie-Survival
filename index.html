<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zombie Survival - Host</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }

    #game-container {
      position: relative;
      overflow: hidden;
    }

    #canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    #room-code-display {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      padding: 15px 30px;
      border-radius: 10px;
      border: 2px solid #00ff00;
      text-align: center;
      z-index: 100;
      transition: opacity 1.5s ease;
      display: flex;
      align-items: center;
      gap: 30px;
    }
    
    body:has(#lobby-screen[style*="display: block"]) #room-code-display,
    body:has(#lobby-screen[style*="display: flex"]) #room-code-display {
      opacity: 0;
      pointer-events: none;
    }

    #room-code-text { text-align: center; }
    #room-code-display p { color: #00ff00; font-size: 16px; margin-bottom: 5px; }
    #room-code { font-size: 48px; font-weight: bold; letter-spacing: 6px; color: #fff; }
    
    #qr-code {
      background: #fff;
      padding: 10px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #qr-code canvas { display: block; }

    #lobby-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 150;
      width: 90%;
      max-width: 600px;
      padding: 20px;
      margin-top: 60px;
    }

    #lobby-players { display: flex; flex-direction: column; gap: 12px; margin-bottom: 30px; margin-top: 40px; }
    .lobby-slot {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(0,0,0,0.8);
      border: 2px solid #333;
      border-radius: 12px;
      padding: 10px 16px;
      font-size: clamp(14px, 3vw, 22px);
      letter-spacing: 2px;
    }
    .lobby-slot.connected { border-color: #555; }
    .lobby-slot.ready     { border-color: #00ff00; }

    .slot-color {
      width: clamp(20px, 4vw, 28px);
      height: clamp(20px, 4vw, 28px);
      border-radius: 4px;
      margin-right: 10px;
      flex-shrink: 0;
    }
    .slot-name { flex: 1; text-align: left; color: #fff; }
    .slot-status {
      font-size: clamp(12px, 2.5vw, 16px);
      letter-spacing: 2px;
      padding: 4px 10px;
      border-radius: 8px;
    }
    .status-waiting { color: #555; border: 1px solid #333; }
    .status-joined  { color: #aaa; border: 1px solid #555; }
    .status-ready   { color: #00ff00; border: 1px solid #00ff00; background: rgba(0,255,0,0.1); }

    #countdown {
      font-size: clamp(60px, 15vw, 100px);
      font-weight: bold;
      color: #ff0000;
      text-shadow: 0 0 30px #ff0000;
      display: none;
      animation: pop 0.3s ease;
    }
    @keyframes pop { 0% { transform: scale(1.4); } 100% { transform: scale(1); } }

    #game-info {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      border: 2px solid #00ff00;
      color: #fff;
      display: none;
    }
    .info-line { font-size: 18px; margin: 5px 0; }
    .info-line span { color: #00ff00; font-weight: bold; }

    #wave-banner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(40px, 10vw, 72px);
      font-weight: bold;
      color: #ff0000;
      text-shadow: 0 0 20px #ff0000;
      display: none;
      z-index: 200;
    }

    #game-over-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      display: none;
      z-index: 200;
      background: rgba(0,0,0,0.9);
      padding: clamp(20px, 5vw, 40px) clamp(30px, 8vw, 60px);
      border-radius: 20px;
      border: 3px solid #ff0000;
      max-width: 90%;
    }
    #game-over-screen h1 {
      font-size: clamp(40px, 10vw, 80px);
      color: #ff0000;
      text-shadow: 0 0 30px #ff0000;
    }
    #game-over-screen p { font-size: clamp(14px, 3vw, 24px); color: #fff; margin-top: 20px; }
    #vote-display { font-size: clamp(16px, 4vw, 28px); color: #00ff00; margin-top: 20px; }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="canvas" width="1334" height="750"></canvas>

    <div id="room-code-display">
      <div id="room-code-text">
        <p>SCAN TO JOIN</p>
        <div id="room-code">----</div>
      </div>
      <div id="qr-code"></div>
    </div>

    <div id="lobby-screen">
      <div id="lobby-players">
        <div class="lobby-slot" id="slot-1">
          <div class="slot-color" style="background:#00ffff"></div>
          <div class="slot-name">PLAYER 1</div>
          <div class="slot-status status-waiting">EMPTY</div>
        </div>
        <div class="lobby-slot" id="slot-2">
          <div class="slot-color" style="background:#ff44ff"></div>
          <div class="slot-name">PLAYER 2</div>
          <div class="slot-status status-waiting">EMPTY</div>
        </div>
        <div class="lobby-slot" id="slot-3">
          <div class="slot-color" style="background:#4488ff"></div>
          <div class="slot-name">PLAYER 3</div>
          <div class="slot-status status-waiting">EMPTY</div>
        </div>
        <div class="lobby-slot" id="slot-4">
          <div class="slot-color" style="background:#ffff00"></div>
          <div class="slot-name">PLAYER 4</div>
          <div class="slot-status status-waiting">EMPTY</div>
        </div>
      </div>
      <div id="countdown"></div>
    </div>

    <div id="game-info">
      <div class="info-line">WAVE: <span id="wave">1</span></div>
      <div class="info-line">ZOMBIES: <span id="zombie-count">0</span></div>
      <div class="info-line">PLAYERS: <span id="player-count">0</span>/4</div>
    </div>

    <div id="wave-banner"></div>
    <div id="game-over-screen">
      <h1>GAME OVER</h1>
      <p>All players have fallen</p>
      <div id="vote-display">Waiting for restart votes...</div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const WEAPONS = {
      pistol:     { name: 'Pistol',        damage: 1,  fireRate: 10, ammoCapacity: 30  },
      smg:        { name: 'SMG',           damage: 1,  fireRate: 5,  ammoCapacity: 60,  rarity: 'common'    },
      shotgun:    { name: 'Shotgun',       damage: 3,  fireRate: 20, ammoCapacity: 24,  rarity: 'common'    },
      ar:         { name: 'Assault Rifle', damage: 2,  fireRate: 7,  ammoCapacity: 45,  rarity: 'rare'      },
      lmg:        { name: 'LMG',           damage: 2,  fireRate: 8,  ammoCapacity: 100, rarity: 'rare'      },
      raygun:     { name: 'Ray Gun',       damage: 5,  fireRate: 12, ammoCapacity: 20,  rarity: 'legendary' },
      thundergun: { name: 'Thundergun',    damage: 10, fireRate: 30, ammoCapacity: 8,   rarity: 'legendary' }
    };

    const ZOMBIE_TYPES = {
      regular: { size: 28, color: '#00cc00', borderColor: '#00ff00', speed: 0.9, hp: 2,  points: 60,  weight: 70 },
      runner:  { size: 20, color: '#cccc00', borderColor: '#ffff00', speed: 1.8, hp: 1,  points: 80,  weight: 20 },
      tank:    { size: 40, color: '#cc0000', borderColor: '#ff0000', speed: 0.5, hp: 8,  points: 150, weight: 10 }
    };

    const MYSTERY_BOX_COST = 950;
    const BOX_USE_RANGE    = 60;

    const MELEE_DAMAGE = 1;
    const MELEE_RANGE  = 55;
    const MELEE_ARC    = Math.PI * 0.6;

    class GameEngine {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx    = this.canvas.getContext('2d');

        this.PLAYER_SIZE  = 28;
        this.BULLET_SIZE  = 6;
        this.AMMO_SIZE    = 20;
        this.BOX_SIZE     = 50;
        this.PLAYER_SPEED = 2.5;
        this.BULLET_SPEED = 8;
        this.REVIVE_RADIUS = 40;
        this.REVIVE_TIME   = 3000;
        this.AMMO_DROP_CHANCE = 0.3;

        // Wall inset â€” border is strokeRect(2,2,W-4,H-4) lineWidth=4, inner edge at 4px
        // Use 6 for a clean pixel buffer so nothing clips through
        this.WALL_INSET = 6;

        this.players    = [];
        this.zombies    = [];
        this.bullets    = [];
        this.ammoPacks  = [];
        this.healthPacks = [];
        this.wave       = 1;
        this.waveTotal  = 0;
        this.waveKilled = 0;
        this.gameOver   = false;
        this.gameStarted = false;
        this.reviveMap  = new Map();
        this.mysteryBox = null;

        this.meleeFlashes = [];
        this.particles   = [];   // Phase 1: client-side explosion particles
        this.boss = null;

        this.socket   = null;
        this.roomCode = null;

        this.initPlayers();
      }

      initPlayers() {
        const colors = ['#00ffff','#ff44ff','#4488ff','#ffff00'];
        const spawns = [
          { x: 80,   y: 80  },
          { x: 1254, y: 80  },
          { x: 80,   y: 670 },
          { x: 1254, y: 670 }
        ];
        for (let i = 0; i < 4; i++) {
          this.players[i] = {
            slot: i + 1,
            x: spawns[i].x, y: spawns[i].y,
            vx: 0, vy: 0, angle: 0,
            color: colors[i],
            hp: 100, maxHp: 100,
            ammo: 30,
            points: 0,
            currentWeapon: 'pistol',
            alive: true, connected: false,
            firing: false, fireCooldown: 0,
            meleeing: false,
            meleeCooldown: 0
          };
        }
      }

      addPlayer(slot)    { this.players[slot-1].connected = true;  this.updateHUD(); }
      removePlayer(slot) { this.players[slot-1].connected = false; this.updateHUD(); }
      connectedCount()   { return this.players.filter(p => p.connected).length; }

      updateLobby(players) {
        for (let i = 1; i <= 4; i++) {
          const slot   = document.getElementById(`slot-${i}`);
          const status = slot.querySelector('.slot-status');
          const found  = players.find(p => p.slotNumber === i);
          if (!found) {
            slot.className = 'lobby-slot'; status.className = 'slot-status status-waiting'; status.textContent = 'EMPTY';
          } else if (found.ready) {
            slot.className = 'lobby-slot ready'; status.className = 'slot-status status-ready'; status.textContent = 'READY!';
          } else {
            slot.className = 'lobby-slot connected'; status.className = 'slot-status status-joined'; status.textContent = 'JOINED';
          }
        }
      }

      startCountdown() {
        const countdown = document.getElementById('countdown');
        countdown.style.display = 'block';
        let count = 3;
        countdown.textContent = count;
        const tick = setInterval(() => {
          count--;
          if (count > 0) {
            countdown.style.animation = 'none';
            countdown.offsetHeight;
            countdown.style.animation = 'pop 0.3s ease';
            countdown.textContent = count;
          } else {
            clearInterval(tick);
            this.beginGame();
          }
        }, 1000);
      }

      beginGame() {
        this.gameStarted = true;
        document.getElementById('lobby-screen').style.display = 'none';
        document.getElementById('game-info').style.display    = 'block';
        const codeDisplay = document.getElementById('room-code-display');
        codeDisplay.style.opacity = '0';
        setTimeout(() => { codeDisplay.style.display = 'none'; }, 1500);
        this.spawnMysteryBox();
        setTimeout(() => this.startWave(), 500);
      }

      handleInput(slot, input) {
        const p = this.players[slot - 1];
        if (!p || !p.alive) return;
        if (input.angle !== null && input.angle !== undefined) {
          p.vx    = Math.cos(input.angle) * this.PLAYER_SPEED;
          p.vy    = Math.sin(input.angle) * this.PLAYER_SPEED;
          p.angle = input.angle;
        } else {
          p.vx = 0; p.vy = 0;
        }
        p.firing   = !!input.fire;
        p.meleeing = !!input.melee;
      }

      handleMysteryBoxPurchase(slot) {
        const p = this.players[slot - 1];
        if (!p || !p.alive || !this.mysteryBox) return;
        const dx = p.x - this.mysteryBox.x, dy = p.y - this.mysteryBox.y;
        if (Math.sqrt(dx*dx+dy*dy) > BOX_USE_RANGE) return;
        if (p.points < MYSTERY_BOX_COST) return;
        p.points -= MYSTERY_BOX_COST;
        const weapon = this.rollRandomWeapon();
        p.currentWeapon = weapon;
        p.ammo = WEAPONS[weapon].ammoCapacity;
        setTimeout(() => this.spawnMysteryBox(), 1000);
      }

      rollRandomWeapon() {
        const roll = Math.random() * 100;
        if (roll < 10) {
          const l = Object.keys(WEAPONS).filter(k => WEAPONS[k].rarity === 'legendary');
          return l[Math.floor(Math.random() * l.length)];
        } else if (roll < 40) {
          const r = Object.keys(WEAPONS).filter(k => WEAPONS[k].rarity === 'rare');
          return r[Math.floor(Math.random() * r.length)];
        } else {
          const c = Object.keys(WEAPONS).filter(k => WEAPONS[k].rarity === 'common');
          return c[Math.floor(Math.random() * c.length)];
        }
      }

      spawnMysteryBox() {
        const margin = 100;
        this.mysteryBox = {
          x: margin + Math.random() * (this.canvas.width  - margin * 2),
          y: margin + Math.random() * (this.canvas.height - margin * 2)
        };
      }

      startWave() {
        const playerCount = Math.max(1, this.connectedCount());
        this.waveKilled = 0;

        // â”€â”€ GUN TEST MODE â€” wave 1 only, cycles through all weapons every 5s â”€â”€
        if (this.wave === 1) {
          const TEST_GUNS = ['pistol', 'smg', 'shotgun', 'ar', 'lmg', 'raygun', 'thundergun'];
          let testIdx = 0;
          this._gunTestInterval = setInterval(() => {
            testIdx = (testIdx + 1) % TEST_GUNS.length;
            const gun = TEST_GUNS[testIdx];
            for (let p of this.players) {
              if (!p.connected) continue;
              p.currentWeapon = gun;
              p.ammo = Infinity;
            }
            this.showBanner('ðŸ”« ' + gun.toUpperCase());
          }, 5000);
          // Give everyone infinite ammo and start on pistol
          for (let p of this.players) {
            if (!p.connected) continue;
            p.currentWeapon = 'pistol';
            p.ammo = Infinity;
          }
          this.showBanner('ðŸ”« PISTOL');
        }
        // â”€â”€ END GUN TEST MODE â”€â”€

        if (this.wave % 5 === 0) {
          this.isBossWave = true;
          this.waveTotal = 1;
          this.showBanner('âš  BOSS WAVE');
          // Unlimited ammo for boss wave â€” save each player's ammo to restore after
          for (let p of this.players) {
            if (!p.connected) continue;
            p.savedAmmo = p.ammo;
            p.ammo = Infinity;
          }
          setTimeout(() => this.spawnBoss(), 2000);
        } else {
          this.isBossWave = false;
          // Restore finite ammo coming out of a boss wave
          for (let p of this.players) {
            if (!p.connected) continue;
            if (p.savedAmmo !== undefined) {
              const weapon = WEAPONS[p.currentWeapon];
              // Give them back their saved ammo, minimum a half-mag so they're not helpless
              p.ammo = Math.max(p.savedAmmo, Math.floor(weapon.ammoCapacity * 0.5));
              p.savedAmmo = undefined;
            }
          }
          const baseCount = 3 + (this.wave - 1) * 2;
          this.waveTotal  = Math.ceil(baseCount * (playerCount / 2));
          this.showBanner('WAVE ' + this.wave);
          for (let i = 0; i < this.waveTotal; i++) {
            setTimeout(() => this.spawnZombie(), i * 500);
          }
        }
      }

      spawnBoss() {
        const W = this.canvas.width, H = this.canvas.height;
        // â”€â”€ FIX 1: No shake during drop â€” save it for the landing impact â”€â”€
        // Random boss colour each wave so it feels different until unique bosses are added
        const bossHues = ['#8844cc','#cc4488','#4488cc','#44cc88','#cc8844','#cc4444','#44cccc'];
        const bossColor = bossHues[Math.floor(Math.random() * bossHues.length)];
        this.boss = {
          x: W / 2, y: -120,
          dropping: true,
          dropTarget: H / 2,
          vx: 0, vy: 0,
          rotation: 0,
          spinSpeed: 0.03,
          radius: 90,
          color: bossColor,
          tips: [
            { hp: 5, maxHp: 5 },
            { hp: 5, maxHp: 5 },
            { hp: 5, maxHp: 5 },
          ],
          flashTimer: 0,
          dead: false,
        };

      }

      updateBoss() {
        if (!this.boss) return;
        const b = this.boss;
        const W = this.canvas.width, H = this.canvas.height;

        // â”€â”€ Dropping entrance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (b.dropping) {
          b.y += 6;
          b.rotation += b.spinSpeed;
          if (b.y >= b.dropTarget) {
            b.y = b.dropTarget;
            b.dropping = false;
            b.vx = 3.5;
            b.vy = 2.5;
          }
          return;
        }

        // Spin faster as tips are destroyed
        const tipsAlive = b.tips.filter(t => t.hp > 0).length;
        b.spinSpeed = 0.03 + (3 - tipsAlive) * 0.025;
        b.rotation += b.spinSpeed;

        // Bounce boundary = circumradius (90) + max tip triangle height (28) + small margin
        // tipSize max = 18 + (5/5)*10 = 28, drawn from the tip point outward
        // Bounce wall = border inner edge (6px) + full boss extent (radius 90 + tip 35 = 125)
        const WALL = 6;
        const pad = b.radius + 35;
        b.x += b.vx;
        b.y += b.vy;

        if (b.x - pad < WALL)     { b.x = WALL + pad;     b.vx =  Math.abs(b.vx); }
        if (b.x + pad > W - WALL) { b.x = W - WALL - pad; b.vx = -Math.abs(b.vx); }
        if (b.y - pad < WALL)     { b.y = WALL + pad;     b.vy =  Math.abs(b.vy); }
        if (b.y + pad > H - WALL) { b.y = H - WALL - pad; b.vy = -Math.abs(b.vy); }

        if (b.flashTimer > 0) b.flashTimer--;

        if (b.tips.every(t => t.hp <= 0) && !b.dead) {
          b.dead = true;
          for (let p of this.players) {
            if (p.alive && p.connected) {
              p.points += 1000;   // boss kill reward
              p.hp = p.maxHp;     // full health recharge for next wave
            }
          }
          // Drop a random scatter of ammo packs around the boss death position
          const dropCount = 4 + Math.floor(Math.random() * 4); // 4-7 packs
          for (let i = 0; i < dropCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist  = 30 + Math.random() * 80;
            this.ammoPacks.push({
              x: b.x + Math.cos(angle) * dist,
              y: b.y + Math.sin(angle) * dist
            });
          }
          setTimeout(() => {
            this.boss = null;
            this.waveKilled = this.waveTotal;
            this.wave++;
            setTimeout(() => this.startWave(), 3000);
          }, 800);
        }

        const hs = this.PLAYER_SIZE / 2;
        for (let p of this.players) {
          if (!p.alive || !p.connected) continue;
          const dx = p.x - b.x, dy = p.y - b.y;
          if (Math.sqrt(dx*dx+dy*dy) < b.radius + hs) {
            p.hp -= 1;
            if (p.hp <= 0 && p.alive) {
              p.alive = false; p.hp = 0;
              this.checkGameOver();
            }
          }
        }
      }

      getBossTipPositions() {
        if (!this.boss) return [];
        const b = this.boss;
        const angles = [
          b.rotation - Math.PI / 2,
          b.rotation - Math.PI / 2 + (2 * Math.PI/3),
          b.rotation - Math.PI / 2 + (4 * Math.PI/3),
        ];
        return angles.map(a => ({
          x: b.x + Math.cos(a) * b.radius,
          y: b.y + Math.sin(a) * b.radius,
        }));
      }

      showBanner(text) {
        const el = document.getElementById('wave-banner');
        el.textContent = text; el.style.display = 'block';
        setTimeout(() => { el.style.display = 'none'; }, 2000);
      }

      spawnZombie() {
        const side = Math.floor(Math.random() * 4);
        const W = this.canvas.width, H = this.canvas.height;
        let x, y;
        if      (side === 0) { x = Math.random()*W; y = -50; }
        else if (side === 1) { x = W+50; y = Math.random()*H; }
        else if (side === 2) { x = Math.random()*W; y = H+50; }
        else                 { x = -50; y = Math.random()*H; }
        const type     = this.rollZombieType();
        const typeData = ZOMBIE_TYPES[type];
        this.zombies.push({
          x, y, type,
          hp: typeData.hp, maxHp: typeData.hp,
          speed: typeData.speed, size: typeData.size,
          color: typeData.color, borderColor: typeData.borderColor,
          points: typeData.points
        });
      }

      rollZombieType() {
        const total = Object.values(ZOMBIE_TYPES).reduce((s, t) => s + t.weight, 0);
        let roll = Math.random() * total;
        for (let type in ZOMBIE_TYPES) { roll -= ZOMBIE_TYPES[type].weight; if (roll <= 0) return type; }
        return 'regular';
      }

      fireBullet(p) {
        const weapon = WEAPONS[p.currentWeapon];
        const bx = p.x + Math.cos(p.angle) * this.PLAYER_SIZE;
        const by = p.y + Math.sin(p.angle) * this.PLAYER_SIZE;
        const w  = p.currentWeapon;

        if (w === 'shotgun') {
          // Shotgun: 6 pellets spread across a cone
          for (let i = 0; i < 6; i++) {
            const spread = (Math.random() - 0.5) * 0.55;
            const a = p.angle + spread;
            this.bullets.push({
              x: bx, y: by,
              vx: Math.cos(a) * this.BULLET_SPEED * (0.8 + Math.random() * 0.4),
              vy: Math.sin(a) * this.BULLET_SPEED * (0.8 + Math.random() * 0.4),
              damage: weapon.damage, color: p.color, weapon: w,
              life: 18 + Math.floor(Math.random() * 8)
            });
          }
        } else {
          this.bullets.push({
            x: bx, y: by,
            vx: Math.cos(p.angle) * this.BULLET_SPEED,
            vy: Math.sin(p.angle) * this.BULLET_SPEED,
            damage: weapon.damage, color: p.color, weapon: w
          });
        }

        // Muzzle flash particles per weapon
        this.spawnMuzzleEffect(bx, by, p.angle, w, p.color);
        if (p.ammo !== Infinity) p.ammo--;
      }

      spawnMuzzleEffect(x, y, angle, weapon, playerColor) {
        switch(weapon) {
          case 'smg': {
            // Small rapid yellow sparks
            for (let i = 0; i < 3; i++) {
              const a = angle + (Math.random()-0.5)*0.4;
              const s = 3 + Math.random()*3;
              this.particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
                color: '#ffee44', life: 6, maxLife: 6, size: 2 });
            }
            break;
          }
          case 'shotgun': {
            // Wide burst of white/orange pellet sparks
            for (let i = 0; i < 10; i++) {
              const a = angle + (Math.random()-0.5)*0.8;
              const s = 2 + Math.random()*5;
              const colors = ['#ffffff','#ffaa00','#ffdd00'];
              this.particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
                color: colors[Math.floor(Math.random()*colors.length)],
                life: 10, maxLife: 10, size: 2+Math.random()*2 });
            }
            break;
          }
          case 'lmg': {
            // Fast orange/yellow machine gun flash
            for (let i = 0; i < 5; i++) {
              const a = angle + (Math.random()-0.5)*0.25;
              const s = 4 + Math.random()*4;
              this.particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
                color: i%2===0 ? '#ff8800' : '#ffff00', life: 7, maxLife: 7, size: 2+Math.random()*2 });
            }
            break;
          }
          case 'ar': {
            // Medium white/yellow flash
            for (let i = 0; i < 4; i++) {
              const a = angle + (Math.random()-0.5)*0.3;
              const s = 3 + Math.random()*4;
              this.particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
                color: i===0 ? '#ffffff' : '#ffcc00', life: 8, maxLife: 8, size: 2 });
            }
            break;
          }
          case 'raygun': {
            // Blue electric arc crackle
            for (let i = 0; i < 8; i++) {
              const a = angle + (Math.random()-0.5)*0.6;
              const s = 2 + Math.random()*6;
              const colors = ['#00aaff','#00ffff','#aaddff','#ffffff'];
              this.particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
                color: colors[Math.floor(Math.random()*colors.length)],
                life: 12, maxLife: 12, size: 1+Math.random()*3, electric: true });
            }
            break;
          }
          case 'thundergun': {
            // Big red shockwave ring
            for (let i = 0; i < 16; i++) {
              const a = (i / 16) * Math.PI * 2;
              const s = 3 + Math.random()*4;
              this.particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
                color: i%3===0 ? '#ffffff' : '#ff2200',
                life: 18, maxLife: 18, size: 3+Math.random()*3, thunder: true });
            }
            break;
          }
        }
      }

      performMelee(p) {
        this.meleeFlashes.push({ x: p.x, y: p.y, angle: p.angle, timer: 8, color: p.color });

        for (let j = this.zombies.length - 1; j >= 0; j--) {
          const z  = this.zombies[j];
          const dx = z.x - p.x, dy = z.y - p.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist > MELEE_RANGE + z.size / 2) continue;

          const angleToZombie = Math.atan2(dy, dx);
          let angleDiff = angleToZombie - p.angle;
          while (angleDiff >  Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          if (Math.abs(angleDiff) > MELEE_ARC / 2) continue;

          z.hp -= MELEE_DAMAGE;

          if (z.hp <= 0) {
            p.points += z.points;
            this.ammoPacks.push({ x: z.x, y: z.y });
            if (Math.random() < 0.08) this.healthPacks.push({ x: z.x, y: z.y });
            this.triggerExplosion(z.x, z.y, z.borderColor); // Phase 1: explosion particles
            this.zombies.splice(j, 1);
            this.waveKilled++;
            if (this.waveKilled >= this.waveTotal && this.zombies.length === 0) {
              this.wave++;
              setTimeout(() => this.startWave(), 3000);
            }
          }
        }

        // Melee can also hit boss tips â€” check each live tip within range/arc
        if (this.boss && !this.boss.dead && !this.boss.dropping) {
          const tips = this.getBossTipPositions();
          for (let t = 0; t < tips.length; t++) {
            if (this.boss.tips[t].hp <= 0) continue;
            const dx   = tips[t].x - p.x, dy = tips[t].y - p.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > MELEE_RANGE + 20) continue; // 20px tip hitbox radius
            const angleToTip = Math.atan2(dy, dx);
            let angleDiff = angleToTip - p.angle;
            while (angleDiff >  Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            if (Math.abs(angleDiff) > MELEE_ARC / 2) continue;
            this.boss.tips[t].hp -= MELEE_DAMAGE;
            this.boss.flashTimer = 6;
          }
        }
      }

      aabb(ax, ay, as, bx, by, bs) {
        return ax < bx+bs && ax+as > bx && ay < by+bs && ay+as > by;
      }

      // Phase 1: spawn local particles from a coordinate + color
      spawnParticles(x, y, color, count = 12) {
        for (let i = 0; i < count; i++) {
          const angle  = Math.random() * Math.PI * 2;
          const speed  = 1.5 + Math.random() * 4;
          const life   = 20 + Math.floor(Math.random() * 20);
          this.particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            color,
            life,
            maxLife: life,
            size: 2 + Math.random() * 4
          });
        }
      }

      // Phase 1: emit explosion to server so all clients get particles
      triggerExplosion(x, y, color) {
        this.spawnParticles(x, y, color); // local immediately
        if (this.socket && this.roomCode) {
          this.socket.emit('explosion', { roomCode: this.roomCode, x, y, color });
        }
      }

      updateRevive() {
        const now = Date.now();
        for (let reviver of this.players) {
          if (!reviver.alive || !reviver.connected) { this.reviveMap.delete(reviver.slot); continue; }
          let found = false;
          for (let target of this.players) {
            if (target.alive || !target.connected || target === reviver) continue;
            const dx = target.x-reviver.x, dy = target.y-reviver.y;
            if (Math.sqrt(dx*dx+dy*dy) <= this.REVIVE_RADIUS) {
              found = true;
              const attempt = this.reviveMap.get(reviver.slot);
              if (!attempt || attempt.targetSlot !== target.slot) {
                this.reviveMap.set(reviver.slot, { targetSlot: target.slot, startTime: now });
              } else if (now - attempt.startTime >= this.REVIVE_TIME) {
                target.alive = true; target.hp = 50;
                this.reviveMap.delete(reviver.slot);
              }
              break;
            }
          }
          if (!found) this.reviveMap.delete(reviver.slot);
        }
      }

      restart() {
        this.zombies = []; this.bullets = []; this.ammoPacks = []; this.healthPacks = [];
        this.wave = 1; this.waveTotal = 0; this.waveKilled = 0;
        this.gameOver = false; this.gameStarted = false;
        this.reviveMap.clear(); this.mysteryBox = null;
        this.meleeFlashes = [];
        this.particles   = [];
        this.boss = null;
        this.isBossWave = false;
        for (let p of this.players) { p.savedAmmo = undefined; }

        const spawns = [
          { x: 80,   y: 80  }, { x: 1254, y: 80  },
          { x: 80,   y: 670 }, { x: 1254, y: 670 }
        ];
        for (let p of this.players) {
          p.x = spawns[p.slot-1].x; p.y = spawns[p.slot-1].y;
          p.vx = 0; p.vy = 0; p.angle = 0;
          p.hp = 100; p.ammo = 30; p.points = 0;
          p.currentWeapon = 'pistol';
          p.alive = true; p.firing = false; p.fireCooldown = 0;
          p.meleeing = false; p.meleeCooldown = 0;
        }
        document.getElementById('game-over-screen').style.display  = 'none';
        document.getElementById('game-info').style.display         = 'none';
        document.getElementById('lobby-screen').style.display      = 'block';
        document.getElementById('countdown').style.display         = 'none';
        document.getElementById('vote-display').textContent        = 'Waiting for restart votes...';

        for (let i = 1; i <= 4; i++) {
          const slot   = document.getElementById(`slot-${i}`);
          const status = slot.querySelector('.slot-status');
          const player = this.players[i-1];
          if (player.connected) {
            slot.className = 'lobby-slot connected'; status.className = 'slot-status status-joined'; status.textContent = 'JOINED';
          } else {
            slot.className = 'lobby-slot'; status.className = 'slot-status status-waiting'; status.textContent = 'EMPTY';
          }
        }
      }

      update() {
        if (this.gameOver || !this.gameStarted) return;
        const W = this.canvas.width, H = this.canvas.height;
        const hs = this.PLAYER_SIZE / 2;
        const wi = this.WALL_INSET;

        for (let i = this.meleeFlashes.length - 1; i >= 0; i--) {
          this.meleeFlashes[i].timer--;
          if (this.meleeFlashes[i].timer <= 0) this.meleeFlashes.splice(i, 1);
        }

        for (let p of this.players) {
          if (!p.connected || !p.alive) continue;

          // Player clamp â€” border inner edge is at wi=4, keep full sprite inside with margin
          // Hard clamp: wall inner edge (6px) + half player size (14px) = 20px
          const WALL = 6;
          const clamp = hs + WALL;
          p.x = Math.max(clamp, Math.min(W - clamp, p.x + p.vx));
          p.y = Math.max(clamp, Math.min(H - clamp, p.y + p.vy));

          const weapon = WEAPONS[p.currentWeapon];
          p.fireCooldown--;
          p.meleeCooldown--;

          if (p.firing && (p.ammo > 0 || p.ammo === Infinity) && p.fireCooldown <= 0) {
            this.fireBullet(p);
            p.fireCooldown = weapon.fireRate;
          }

          if (p.meleeing && p.ammo === 0 && p.ammo !== Infinity && p.meleeCooldown <= 0) {
            this.performMelee(p);
            p.meleeCooldown = 1;
          }
        }

        // Bullets
        for (let i = this.bullets.length-1; i >= 0; i--) {
          const b = this.bullets[i];
          b.x += b.vx; b.y += b.vy;
          if (b.life !== undefined) { b.life--; if (b.life <= 0) { this.bullets.splice(i, 1); continue; } }
          if (b.x < 0 || b.x > W || b.y < 0 || b.y > H) { this.bullets.splice(i, 1); continue; }
          let hit = false;
          for (let j = this.zombies.length-1; j >= 0; j--) {
            const z = this.zombies[j];
            // Phase 1: circle collision â€” faster and more natural feeling than AABB
            const bdx = b.x - z.x, bdy = b.y - z.y;
            if (Math.sqrt(bdx*bdx + bdy*bdy) < z.size / 2 + this.BULLET_SIZE / 2) {
              z.hp -= b.damage;
              hit = true;
              if (z.hp <= 0) {
                let nearest = null, nearestDist = Infinity;
                for (let p of this.players) {
                  if (!p.alive || !p.connected) continue;
                  const dx = p.x-z.x, dy = p.y-z.y;
                  const dist = Math.sqrt(dx*dx+dy*dy);
                  if (dist < nearestDist) { nearestDist = dist; nearest = p; }
                }
                if (nearest) nearest.points += z.points;
                if (Math.random() < this.AMMO_DROP_CHANCE) this.ammoPacks.push({ x: z.x, y: z.y });
                if (Math.random() < 0.08) this.healthPacks.push({ x: z.x, y: z.y });
                this.triggerExplosion(z.x, z.y, z.borderColor); // Phase 1: explosion particles
                this.zombies.splice(j, 1);
                this.waveKilled++;
                if (this.waveKilled >= this.waveTotal && this.zombies.length === 0) {
                  // Clear gun test interval when wave 1 ends
                  if (this._gunTestInterval) { clearInterval(this._gunTestInterval); this._gunTestInterval = null; }
                  this.wave++;
                  setTimeout(() => this.startWave(), 3000);
                }
              }
              break;
            }
          }
          if (hit) { this.bullets.splice(i, 1); continue; }

          if (this.boss && !this.boss.dead && !this.boss.dropping) {
            const tips = this.getBossTipPositions();
            for (let t = 0; t < tips.length; t++) {
              const tip = tips[t];
              const dx = b.x - tip.x, dy = b.y - tip.y;
              if (Math.sqrt(dx*dx+dy*dy) < 22 && this.boss.tips[t].hp > 0) {
                this.boss.tips[t].hp--;
                this.boss.flashTimer = 6;
                this.bullets.splice(i, 1);
                hit = true;
                break;
              }
            }
          }
          if (hit) this.bullets.splice(i, 1);
        }

        // Zombies
        for (let z of this.zombies) {
          let nearest = null, nearestDist = Infinity;
          for (let p of this.players) {
            if (!p.alive || !p.connected) continue;
            const dx = p.x-z.x, dy = p.y-z.y;
            const dist = Math.sqrt(dx*dx+dy*dy);
            if (dist < nearestDist) { nearestDist = dist; nearest = p; }
          }
          if (!nearest) continue;
          const dx = nearest.x-z.x, dy = nearest.y-z.y;
          const dist = Math.sqrt(dx*dx+dy*dy);
          if (dist > 0) { z.x += (dx/dist)*z.speed; z.y += (dy/dist)*z.speed; }
          // Phase 1: circle collision for zombie-player contact
          const zr = z.size / 2, pr = this.PLAYER_SIZE / 2;
          const zpDx = nearest.x - z.x, zpDy = nearest.y - z.y;
          if (Math.sqrt(zpDx*zpDx + zpDy*zpDy) < zr + pr) {
            nearest.hp -= 0.5;
            if (nearest.hp <= 0 && nearest.alive) {
              nearest.alive = false; nearest.hp = 0;
              this.checkGameOver();
            }
          }
        }

        // Ammo pickups
        for (let i = this.ammoPacks.length-1; i >= 0; i--) {
          const a = this.ammoPacks[i];
          const hs2 = this.PLAYER_SIZE / 2;
          for (let p of this.players) {
            if (!p.alive) continue;
            if (this.aabb(a.x-this.AMMO_SIZE/2, a.y-this.AMMO_SIZE/2, this.AMMO_SIZE,
                          p.x-hs2, p.y-hs2, this.PLAYER_SIZE)) {
              const weapon = WEAPONS[p.currentWeapon];
              p.ammo += Math.floor(weapon.ammoCapacity * 0.5);
              this.ammoPacks.splice(i, 1);
              break;
            }
          }
        }

        // Phase 1: update particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const pt = this.particles[i];
          pt.x  += pt.vx;
          pt.y  += pt.vy;
          pt.vx *= 0.92; // friction
          pt.vy *= 0.92;
          pt.life--;
          if (pt.life <= 0) this.particles.splice(i, 1);
        }

        // Health pack pickups
        for (let i = this.healthPacks.length - 1; i >= 0; i--) {
          const h = this.healthPacks[i];
          for (let p of this.players) {
            if (!p.alive) continue;
            const hs2 = this.PLAYER_SIZE / 2;
            if (this.aabb(h.x - 10, h.y - 10, 20, p.x - hs2, p.y - hs2, this.PLAYER_SIZE)) {
              p.hp = Math.min(p.maxHp, p.hp + 30); // restore 30hp, cap at max
              this.healthPacks.splice(i, 1);
              break;
            }
          }
        }

        this.updateRevive();
        this.updateBoss();
      }

      checkGameOver() {
        const anyAlive = this.players.some(p => p.alive && p.connected);
        if (!anyAlive) {
          this.gameOver = true;
          document.getElementById('game-over-screen').style.display = 'block';
        }
      }

      render() {
        const ctx = this.ctx;
        const W = this.canvas.width, H = this.canvas.height;
        const hs = this.PLAYER_SIZE / 2;

        // Screen shake removed â€” content renders cleanly without transform offset
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, W, H);

        // Grid
        ctx.strokeStyle = 'rgba(0,255,0,0.05)'; ctx.lineWidth = 1;
        for (let x = 0; x < W; x += 60) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
        for (let y = 0; y < H; y += 60) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

        // Mystery box
        if (this.mysteryBox) {
          const bhs = this.BOX_SIZE / 2;
          ctx.shadowColor = '#bb00ff'; ctx.shadowBlur = 20;
          ctx.fillStyle = '#bb00ff';
          ctx.fillRect(this.mysteryBox.x-bhs, this.mysteryBox.y-bhs, this.BOX_SIZE, this.BOX_SIZE);
          ctx.shadowBlur = 0;
          ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 3;
          ctx.strokeRect(this.mysteryBox.x-bhs, this.mysteryBox.y-bhs, this.BOX_SIZE, this.BOX_SIZE);
          ctx.fillStyle = '#fff'; ctx.font = 'bold 32px Courier New';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText('?', this.mysteryBox.x, this.mysteryBox.y);
        }

        // Ammo packs
        for (let a of this.ammoPacks) {
          ctx.fillStyle = '#ffff00';
          ctx.fillRect(a.x-this.AMMO_SIZE/2, a.y-this.AMMO_SIZE/2, this.AMMO_SIZE, this.AMMO_SIZE);
          ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 2;
          ctx.strokeRect(a.x-this.AMMO_SIZE/2, a.y-this.AMMO_SIZE/2, this.AMMO_SIZE, this.AMMO_SIZE);
          ctx.fillStyle = '#000'; ctx.font = 'bold 12px Courier New';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText('A', a.x, a.y);
        }

        // Health packs â€” red cross
        for (let h of this.healthPacks) {
          ctx.fillStyle = '#222';
          ctx.fillRect(h.x - 10, h.y - 10, 20, 20);
          ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2;
          ctx.strokeRect(h.x - 10, h.y - 10, 20, 20);
          ctx.fillStyle = '#ff3333';
          ctx.fillRect(h.x - 7, h.y - 2, 14, 4);
          ctx.fillRect(h.x - 2, h.y - 7, 4, 14);
        }

        // Zombies
        for (let z of this.zombies) {
          const zhs = z.size / 2, zx = z.x-zhs, zy = z.y-zhs;
          ctx.fillStyle = z.color; ctx.fillRect(zx, zy, z.size, z.size);
          ctx.strokeStyle = z.borderColor; ctx.lineWidth = 2; ctx.strokeRect(zx, zy, z.size, z.size);
          ctx.fillStyle = '#ff0000'; ctx.fillRect(z.x-zhs, zy-8, z.size, 4);
          ctx.fillStyle = '#00ff00'; ctx.fillRect(z.x-zhs, zy-8, z.size*(z.hp/z.maxHp), 4);
        }

        // Bullets â€” weapon-specific visuals
        for (let b of this.bullets) {
          ctx.save();
          switch(b.weapon) {
            case 'shotgun': {
              // Small fast pellets
              ctx.fillStyle = '#ffcc66'; ctx.shadowColor = '#ffaa00'; ctx.shadowBlur = 4;
              ctx.beginPath(); ctx.arc(b.x, b.y, 2, 0, Math.PI*2); ctx.fill();
              break;
            }
            case 'smg': {
              // Tiny rapid sparks â€” elongated in direction of travel
              const smgA = Math.atan2(b.vy, b.vx);
              ctx.fillStyle = '#ffee44'; ctx.shadowColor = '#ffee44'; ctx.shadowBlur = 6;
              ctx.translate(b.x, b.y); ctx.rotate(smgA);
              ctx.fillRect(-5, -1.5, 10, 3);
              break;
            }
            case 'lmg': {
              // Elongated orange tracer
              const lmgA = Math.atan2(b.vy, b.vx);
              ctx.fillStyle = '#ff8800'; ctx.shadowColor = '#ffaa00'; ctx.shadowBlur = 8;
              ctx.translate(b.x, b.y); ctx.rotate(lmgA);
              ctx.fillRect(-7, -2, 14, 4);
              break;
            }
            case 'raygun': {
              // Blue glowing orb with crackle halo
              ctx.fillStyle = '#00ccff'; ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 20;
              ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
              ctx.strokeStyle = '#aaeeff'; ctx.lineWidth = 1; ctx.globalAlpha = 0.5;
              ctx.beginPath(); ctx.arc(b.x, b.y, 7, 0, Math.PI*2); ctx.stroke();
              break;
            }
            case 'thundergun': {
              // Large red pulsing blast
              ctx.fillStyle = '#ff2200'; ctx.shadowColor = '#ff4400'; ctx.shadowBlur = 30;
              ctx.beginPath(); ctx.arc(b.x, b.y, 7, 0, Math.PI*2); ctx.fill();
              ctx.fillStyle = '#ffffff'; ctx.shadowBlur = 10;
              ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
              break;
            }
            default: {
              // Pistol / AR â€” standard bullet
              ctx.fillStyle = b.color; ctx.shadowColor = b.color; ctx.shadowBlur = 8;
              ctx.beginPath(); ctx.arc(b.x, b.y, this.BULLET_SIZE/2, 0, Math.PI*2); ctx.fill();
            }
          }
          ctx.restore();
        }

        // Phase 1: render particles
        for (let pt of this.particles) {
          const alpha = pt.life / pt.maxLife;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle   = pt.color;
          ctx.shadowColor = pt.color;
          ctx.shadowBlur  = 6;
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, pt.size * alpha, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Melee arc flashes
        for (let f of this.meleeFlashes) {
          const alpha = f.timer / 8;
          ctx.save();
          ctx.globalAlpha = alpha * 0.55;
          ctx.fillStyle   = f.color;
          ctx.shadowColor = f.color;
          ctx.shadowBlur  = 20;
          ctx.beginPath();
          ctx.moveTo(f.x, f.y);
          ctx.arc(f.x, f.y, MELEE_RANGE, f.angle - MELEE_ARC / 2, f.angle + MELEE_ARC / 2);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }

        // Boss
        if (this.boss && !this.boss.dead) {
          const b = this.boss;
          const tips = this.getBossTipPositions();
          const flashing = b.flashTimer > 0 && b.flashTimer % 2 === 0;

          ctx.save();
          ctx.translate(b.x, b.y);
          ctx.rotate(b.rotation);

          ctx.beginPath();
          for (let i = 0; i < 3; i++) {
            const a = -Math.PI/2 + (i * 2 * Math.PI / 3);
            const px = Math.cos(a) * b.radius;
            const py = Math.sin(a) * b.radius;
            i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.fillStyle   = flashing ? '#ffffff' : b.color;
          ctx.shadowColor = '#bb00ff';
          ctx.shadowBlur  = 30;
          ctx.fill();
          ctx.strokeStyle = '#000';
          ctx.lineWidth   = 4;
          ctx.stroke();
          ctx.shadowBlur  = 0;
          ctx.restore();

          for (let t = 0; t < 3; t++) {
            const tip = tips[t];
            const bossT = b.tips[t];
            if (bossT.hp <= 0) continue;

            const tipAngle = b.rotation - Math.PI/2 + t * (2*Math.PI/3);
            const tipSize  = 18 + (bossT.hp / bossT.maxHp) * 10;

            ctx.save();
            ctx.translate(tip.x, tip.y);
            ctx.rotate(tipAngle);
            ctx.beginPath();
            ctx.moveTo(0, -tipSize);
            ctx.lineTo(-tipSize * 0.8, tipSize * 0.6);
            ctx.lineTo(tipSize * 0.8, tipSize * 0.6);
            ctx.closePath();
            ctx.fillStyle   = flashing ? '#ffaaaa' : '#cc0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur  = 15;
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth   = 2;
            ctx.stroke();
            ctx.shadowBlur  = 0;

            const barW = 40, barH = 5;
            ctx.fillStyle = '#330000';
            ctx.fillRect(-barW/2, tipSize + 4, barW, barH);
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(-barW/2, tipSize + 4, barW * (bossT.hp / bossT.maxHp), barH);
            ctx.restore();
          }

          ctx.fillStyle = '#ff44ff';
          ctx.font = 'bold 16px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('BOSS', b.x, b.y - b.radius - 20);
        }

        // â”€â”€ Arena border â€” always on top, always visible â”€â”€
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 4;
        ctx.shadowColor = '#00ff00';
        ctx.shadowBlur = 14;
        ctx.strokeRect(2, 2, W-4, H-4);
        ctx.shadowBlur = 0;

        // Players (drawn outside shake so they feel stable)
        for (let p of this.players) {
          if (!p.connected) continue;
          if (p.alive) {
            ctx.shadowColor = p.color; ctx.shadowBlur = 15;
            ctx.fillStyle   = p.color;
            ctx.fillRect(p.x-hs, p.y-hs, this.PLAYER_SIZE, this.PLAYER_SIZE);
            ctx.shadowBlur  = 0;
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x+Math.cos(p.angle)*(hs+12), p.y+Math.sin(p.angle)*(hs+12));
            ctx.stroke();
            ctx.fillStyle = '#ff0000'; ctx.fillRect(p.x-hs, p.y-hs-10, this.PLAYER_SIZE, 5);
            ctx.fillStyle = '#00ff00'; ctx.fillRect(p.x-hs, p.y-hs-10, this.PLAYER_SIZE*(p.hp/p.maxHp), 5);
            ctx.fillStyle = '#ffff00'; ctx.font = 'bold 12px Courier New';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(`$${p.points}`, p.x, p.y-hs-20);

            if (p.ammo === 0) {
              ctx.fillStyle = '#00ff66'; ctx.font = 'bold 11px Courier New';
              ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
              ctx.fillText('KNIFE', p.x, p.y - hs - 32);
            }
          } else {
            ctx.fillStyle = '#444'; ctx.fillRect(p.x-hs, p.y-hs, this.PLAYER_SIZE, this.PLAYER_SIZE);
            ctx.strokeStyle = '#888'; ctx.lineWidth = 2;
            ctx.setLineDash([4,4]); ctx.strokeRect(p.x-hs, p.y-hs, this.PLAYER_SIZE, this.PLAYER_SIZE);
            ctx.setLineDash([]);
            for (let [, attempt] of this.reviveMap) {
              if (attempt.targetSlot === p.slot) {
                const progress = Math.min((Date.now()-attempt.startTime)/this.REVIVE_TIME, 1);
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(p.x, p.y, hs+8, -Math.PI/2, -Math.PI/2+Math.PI*2*progress);
                ctx.stroke();
              }
            }
          }
          ctx.fillStyle = '#fff'; ctx.font = 'bold 13px Courier New';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText('P'+p.slot, p.x, p.y);
        }

        this.updateHUD();
      }

      updateHUD() {
        document.getElementById('wave').textContent         = this.wave;
        document.getElementById('zombie-count').textContent = this.zombies.length;
        document.getElementById('player-count').textContent = this.connectedCount();
      }

      canUseMysteryBox(player) {
        if (!this.mysteryBox || !player.alive) return false;
        const dx = player.x - this.mysteryBox.x, dy = player.y - this.mysteryBox.y;
        return Math.sqrt(dx*dx+dy*dy) <= BOX_USE_RANGE;
      }

      start() {
        let lastTime = 0;
        const frameDelay = 1000 / 60;
        const loop = (currentTime) => {
          const deltaTime = currentTime - lastTime;
          if (deltaTime >= frameDelay) {
            this.update();
            this.render();
            if (this.socket && this.roomCode) {
              this.socket.emit('game-state-broadcast', {
                roomCode: this.roomCode,
                gameState: {
                  wave: this.wave,
                  zombiesRemaining: this.zombies.length,
                  gameOver: this.gameOver,
                  players: this.players.map(p => ({
                    health: p.hp,
                    ammo: p.ammo === Infinity ? -1 : p.ammo,
                    isAlive: p.alive,
                    points: p.points,
                    weapon: p.currentWeapon,
                    canUseMysteryBox: this.canUseMysteryBox(p)
                  }))
                }
              });
            }
            lastTime = currentTime - (deltaTime % frameDelay);
          }
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    const game   = new GameEngine();
    const socket = io({ transports: ['websocket'] }); // Phase 1: stable Render connections
    game.socket  = socket;

    socket.on('connect',      () => socket.emit('create-room'));
    socket.on('room-created', (data) => {
      game.roomCode = data.roomCode;
      document.getElementById('room-code').textContent = data.roomCode;
      new QRCode(document.getElementById('qr-code'), {
        text: `${window.location.origin}/controller.html`,
        width: 128, height: 128,
        colorDark: '#000000', colorLight: '#ffffff',
        correctLevel: QRCode.CorrectLevel.M
      });
      game.start();
    });

    // Phase 1: receive explosion events from other clients via server relay
    socket.on('explosion', (d) => game.spawnParticles(d.x, d.y, d.color));

    socket.on('player-joined',        (d) => game.addPlayer(d.slotNumber));
    socket.on('player-disconnected',  (d) => game.removePlayer(d.slotNumber));
    socket.on('player-removed',       (d) => game.removePlayer(d.slotNumber));
    socket.on('player-input',         (d) => game.handleInput(d.slotNumber, d.input));
    socket.on('mystery-box-purchase', (d) => game.handleMysteryBoxPurchase(d.slotNumber));
    socket.on('lobby-update',         (d) => game.updateLobby(d.players));
    socket.on('all-ready',            ()  => game.startCountdown());
    socket.on('restart-game',         ()  => game.restart());
    socket.on('restart-vote-update',  (d) => {
      document.getElementById('vote-display').textContent =
        `Restart votes: ${d.votes} / ${d.needed} - Vote YES on your phone!`;
    });

    const BASE_W = 1334;
    const BASE_H = 750;

    function scaleCanvas() {
      const container = document.getElementById('game-container');
      const canvas    = document.getElementById('canvas');
      const scale = Math.min(window.innerWidth / BASE_W, window.innerHeight / BASE_H);
      canvas.width  = BASE_W;
      canvas.height = BASE_H;
      container.style.width     = BASE_W + 'px';
      container.style.height    = BASE_H + 'px';
      container.style.transform = `scale(${scale})`;
      container.style.transformOrigin = 'top left';
      // Manually centre using position:absolute + left/top offset
      // This works correctly on all devices including iPad with browser chrome
      const scaledW = BASE_W * scale;
      const scaledH = BASE_H * scale;
      container.style.position = 'absolute';
      container.style.left = Math.floor((window.innerWidth  - scaledW) / 2) + 'px';
      container.style.top  = Math.floor((window.innerHeight - scaledH) / 2) + 'px';
    }

    scaleCanvas();
    window.addEventListener('resize', scaleCanvas);
    window.addEventListener('orientationchange', () => setTimeout(scaleCanvas, 100));

  </script>
</body>
</html>
